"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[8611],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),m=d(t),u=i,f=m["".concat(s,".").concat(u)]||m[u]||p[u]||o;return t?a.createElement(f,l(l({ref:n},c),{},{components:t})):a.createElement(f,l({ref:n},c))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,l=new Array(o);l[0]=m;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var d=2;d<o;d++)l[d]=t[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3883:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=t(7462),i=(t(7294),t(3905));const o={id:"page-3",title:"Encapsulation",sidebar_position:3},l=void 0,r={unversionedId:"turing-tako/complex-data/page-3",id:"turing-tako/complex-data/page-3",title:"Encapsulation",description:"Encapsulation is a fundemental concept in software engineering because typically software is built by many people. The issue with multiple people coding one large software system is that it is very likely that they are going to want to use the same function names for two different functions. This is problem we will be able to solve using encapsulation.",source:"@site/docs/turing-tako/complex-data/local.mdx",sourceDirName:"turing-tako/complex-data",slug:"/turing-tako/complex-data/page-3",permalink:"/NoTako/docs/turing-tako/complex-data/page-3",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/complex-data/local.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"page-3",title:"Encapsulation",sidebar_position:3},sidebar:"turingSidebar",previous:{title:"Cross Product Table",permalink:"/NoTako/docs/turing-tako/complex-data/page-2"},next:{title:"Abstraction",permalink:"/NoTako/docs/turing-tako/complex-data/page-4"}},s={},d=[{value:"Local",id:"local",level:2},{value:"Lexical Scoping",id:"lexical-scoping",level:3},{value:"Evaluation",id:"evaluation",level:3},{value:"Encapsulation",id:"encapsulation",level:2},{value:"Performance",id:"performance",level:2}],c={toc:d};function p(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Encapsulation is a fundemental concept in software engineering because typically software is built by many people. The issue with multiple people coding one large software system is that it is very likely that they are going to want to use the same function names for two different functions. This is problem we will be able to solve using encapsulation."),(0,i.kt)("h2",{id:"local"},"Local"),(0,i.kt)("p",null,"To be able to do encapsulation, we have a new primitive called ",(0,i.kt)("inlineCode",{parentName:"p"},"local"),". To form a local expression, we use the syntax: ",(0,i.kt)("inlineCode",{parentName:"p"},"(local [<definition> ...] <expression>)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Local" showLineNumbers',title:'"Local"',showLineNumbers:!0},"; Adding numbers up together\n(local [(define a 1)\n        (define b 2)]\n    (+ a b))\n")),(0,i.kt)("p",null,"Local lets us add a and b together but the variable does not exist after ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," is completed. This makes those variables self contained meaning a and b are not defined outside the ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," and another variable could be named a and b outside ",(0,i.kt)("inlineCode",{parentName:"p"},"local"),"."),(0,i.kt)("h3",{id:"lexical-scoping"},"Lexical Scoping"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Lexical Scoping"))," is how variables works with ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," and if we want to use this new primitive well, we need to understand this concept well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Lexical Scoping" showLineNumbers',title:'"Lexical','Scoping"':!0,showLineNumbers:!0},"(define a 1)\n(define b 2)\n\n(+ a\n    (local [(define b 3)\n            (define c 4)]\n        (+ a b c))\n    b)\n\n(define c 1)\n")),(0,i.kt)("p",null,"In this case ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," are defined at the start as ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," respectively. The first thing we should look at is the ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," get defined. In this case ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is redefined to ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," and it is valid because it is inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"local"),". So inside the local, ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is still ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"3"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"4")," so ",(0,i.kt)("inlineCode",{parentName:"p"},"(+ a b c)")," evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"8"),". This means the ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," is done, this means the ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," after the local is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),". The redefinition only exists within the ",(0,i.kt)("inlineCode",{parentName:"p"},"local"),", so ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," is still ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," outside it. This made the final expression ",(0,i.kt)("inlineCode",{parentName:"p"},"(+ 1 8 2)")," and the final result was ",(0,i.kt)("inlineCode",{parentName:"p"},"10"),"."),(0,i.kt)("p",null,"The other thing to note is the ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," that is defined after which is again not going to toss an error because once the ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," was done, those variable definitions disappeared."),(0,i.kt)("p",null,"When we define the variable outside all locals, it is the top level scope or what we call the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"global scope")),". Each local creates a smaller scope and when we are looking for a definition for a variable being used, we look at the innermost ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," and work our way to the top scope till we find a definition and use the first one we find."),(0,i.kt)("h3",{id:"evaluation"},"Evaluation"),(0,i.kt)("p",null,"We have one last step to fully grasping how ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," works and that is to look at how it is evaluated. There are three steps that any evaluation of local takes, they include renaming, lifting and replacing."),(0,i.kt)("p",null,"Lets evaluate the expression..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Evaluation" showLineNumbers',title:'"Evaluation"',showLineNumbers:!0},"(define b 1)\n\n(+ b\n    (local [(define b 2)]\n        (* b b))\n    b)\n\n;  We can substitute the first variable\n\n(+ 1\n    (local [(define b 2)\n        (* b b)])\n    b)\n")),(0,i.kt)("p",null,"Now we are up to the first step of ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," where each variable that is defined in the local gets a randomly generated name that is unique to the program. That name is used to rename every occurence of the variable in the local. This step is called ",(0,i.kt)("inlineCode",{parentName:"p"},"renaming"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Renaming" showLineNumbers',title:'"Renaming"',showLineNumbers:!0},"(define b 1)\n\n(+ 1\n    (local [(define b_0 2)\n        (* b_0 b_0)])\n    b)\n")),(0,i.kt)("p",null,"Next step is ",(0,i.kt)("inlineCode",{parentName:"p"},"lifting")," where the computer lifts the newly named definition to the global scope."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Lifting" showLineNumbers',title:'"Lifting"',showLineNumbers:!0},"(define b 1)\n(define b_0 2)\n\n(+ 1\n   (local []\n     (* b_0 b_0)) \n   b)\n")),(0,i.kt)("p",null,"The last step to deal with the ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"replacing")," where we replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," primitive with the body."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Replacing" showLineNumbers',title:'"Replacing"',showLineNumbers:!0},"(define b 1)\n(define b_0 2)\n\n(+ 1\n    (* b_0 b_0)\n    b)\n")),(0,i.kt)("p",null,"Now that ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," is dealt with, we can evaluate the renaming part of the expression like we normally did."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Completing Expression" showLineNumbers',title:'"Completing','Expression"':!0,showLineNumbers:!0},"(+ 1\n    (* 2 2)\n    1)\n\n(+ 1 4 1)\n\n6 ; Solution to expression\n")),(0,i.kt)("h2",{id:"encapsulation"},"Encapsulation"),(0,i.kt)("p",null,"Now that we deeply understand how to use ",(0,i.kt)("inlineCode",{parentName:"p"},"local"),", we can start working with encapsulation. As shown, we are able to self contain sections of code allowing us to fix the issue where programmers could come up with the same names for variables. Encapsulation is the idea that we can self contain sections of code and only leave a few well defined functions with names everyone can agree with."),(0,i.kt)("p",null,"Let's look at the function from a previous section..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Wayback Machine" showLineNumbers',title:'"Wayback','Machine"':!0,showLineNumbers:!0},"; Node -> Integer (For First Function)\n; ListOfNode -> Integer (For Second Function)\n; produce the sum of all the data in element (and its children)\n\n#;\n(define (sum-data--node n) 0) ; stub\n#;\n(define (sum-data--lon lon) 0) ; stub\n\n(check-expect (sum-data--node T1) 1)\n(check-expect (sum-data--lon empty) 0)\n(check-expect (sum-data--node T5) (+ 5 3))\n(check-expect (sum-data--node T4) (+ 4 1 2))\n(check-expect (sum-data--node T6) (+ 6 4 1 2 5 3))\n\n\n(define (sum-data--node n)\n  (+ (node-data n)\n     (sum-data--lon (node-children n))))\n\n(define (sum-data--lon lon)\n  (cond [(empty? lon) 0]\n        [else\n         (+ (sum-data--node (first lon))\n              (sum-data--lon (rest lon)))]))\n")),(0,i.kt)("p",null,"The functions were named ",(0,i.kt)("inlineCode",{parentName:"p"},"sum-data--node")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sum-data--lon")," but the user would only need to call ",(0,i.kt)("inlineCode",{parentName:"p"},"sum-data--node")," to use this function. We had to name these functions weirdly due to the fact we needed two to solve functions to solve the problem. Outside the implementation, we should not worry about how it works, so we can encapsulate all this code and give it one well defined function name that we can use later."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Encapsulation" showLineNumbers',title:'"Encapsulation"',showLineNumbers:!0},"(define (sum-data n) \n    (local [\n        (define (sum-data--node n)\n            (+ (node-data n)\n            (sum-data--lon (node-children n))))\n\n        (define (sum-data--lon lon)\n            (cond [(empty? lon) 0]\n                [else\n                    (+ (sum-data--node (first lon))\n                    (sum-data--lon (rest lon)))]))\n        ]\n        (sum-data--node n)\n    )\n)\n")),(0,i.kt)("p",null,"By encapsulating the function definition into one ",(0,i.kt)("inlineCode",{parentName:"p"},"local"),", the only function name that globally exists is ",(0,i.kt)("inlineCode",{parentName:"p"},"sum-data")," and we don't need to worry about the implementation once the function is created, only how to use it."),(0,i.kt)("h2",{id:"performance"},"Performance"),(0,i.kt)("p",null,"Another benefit of ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," are being able to fix performance issues. We always want to keep our programs efficient so finding ways to make them run faster is a good idea. Let's look at another piece of code we did before."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Wayback Machine Pt. 2" showLineNumbers',title:'"Wayback',Machine:!0,"Pt.":!0,'2"':!0,showLineNumbers:!0},'; String Node -> Integer or false\n; String ListOfNode -> Integer or false\n; search the given tree for a node with the given name, produce data if found; false otherwise\n\n#;\n(define (find--node val n) false) ; stub\n#;\n(define (find--lon val lon) false) ; stub\n\n(check-expect (find--lon "T1" empty) false)\n(check-expect (find--node "T2" T1) false)\n(check-expect (find--node "T3" T3) 3)\n(check-expect (find--node "T4" T4) 4)\n(check-expect (find--lon "T2" (cons T1 (cons T2 empty))) 2)\n(check-expect (find--lon "T3" (cons T1 (cons T2 empty))) false)\n(check-expect (find--node "T3" T4) false)\n(check-expect (find--node "T1" T4) 1)\n(check-expect (find--node "T2" T4) 2)\n(check-expect (find--node "T4" T4) 4)\n(check-expect (find--node "T3" T6) 3)\n\n(define (find--node val n)\n  (if (string=? (node-name n) val)\n      (node-data n)\n      (find--lon val (node-children n))))\n\n(define (find--lon val lon)\n  (cond [(empty? lon) false]\n        [else\n         (if (not (false? (find--node val (first lon))))\n             (find--node val (first lon))\n             (find--lon val (rest lon)))])) \n')),(0,i.kt)("p",null,"We can check its performance with the ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," primitive which basically tells us how long it takes for a given primitive to run. The syntax is ",(0,i.kt)("inlineCode",{parentName:"p"},"(time <expression>)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Performance Testing" showLineNumbers',title:'"Performance','Testing"':!0,showLineNumbers:!0},';; Natural -> Element\n;; produce a skinny tree n+1 deep, leaf has name "Y" data 1\n(check-expect (make-skinny 0) (make-elt "Y" 1 empty))\n(check-expect (make-skinny 2) (make-elt "X" 0 (list (make-elt "X" 0 (list (make-elt "Y" 1 empty))))))\n\n(define (make-skinny n)\n  (cond [(zero? n) (make-elt "Y" 1 empty)]\n        [else\n         (make-elt "X" 0 (list (make-skinny (sub1 n))))]))\n\n\n(time (find--node "Y" (make-skinny 10)))\n(time (find--node "Y" (make-skinny 11)))\n(time (find--node "Y" (make-skinny 12)))\n(time (find--node "Y" (make-skinny 13)))\n(time (find--node "Y" (make-skinny 14)))\n(time (find--node "Y" (make-skinny 15)))\n')),(0,i.kt)("p",null,"We made a function to make big trees because if we run this we notice that as the tree gets one deeper, the time it takes to search exponentially grows. A contributing factor to this slow runtime is that we do ",(0,i.kt)("inlineCode",{parentName:"p"},"(find--node val (first lon))")," twice quite often."),(0,i.kt)("p",null,"To fix this issue, we can use local and define a variable that holds the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"(find--node val (first lon))"),". This way we only run it once and can use it twice."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Performance Fix" showLineNumbers',title:'"Performance','Fix"':!0,showLineNumbers:!0},"(define (find--node val n)\n  (if (string=? (node-name n) val)\n      (node-data n)\n      (find--lon val (node-children n))))\n\n(define (find--lon val lon)\n  (cond [(empty? lon) false]\n        [else\n         (local [(define found (find--node val (first lon)))])\n         (if (not (false? found))\n             found\n             (find--lon val (rest lon)))]))\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Local is useful in avoiding recomputation which can be a useful tool for making various algorithms run faster.")))}p.isMDXComponent=!0}}]);