"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[678],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(n),h=r,u=m["".concat(l,".").concat(h)]||m[h]||p[h]||o;return n?a.createElement(u,i(i({ref:t},d),{},{components:n})):a.createElement(u,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},231:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294);function r(e){return a.createElement("figure",{style:{textAlign:"center"}},a.createElement("img",{src:e.src,alt:e.caption}),a.createElement("figcaption",null,a.createElement("i",null,"Fig. ",e.num," - ",e.caption)))}},7332:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>m});var a=n(7462),r=(n(7294),n(3905)),o=n(231);const i=n.p+"assets/images/complex-data-6-bd5894434bf9c9d7b4c5b3bc1a46a764.png",s=n.p+"assets/images/complex-data-7-37a16eaa06d7757209d3f75726b8a4e1.png",l={id:"page-9",title:"Graphs",sidebar_position:9},c=void 0,d={unversionedId:"turing-tako/complex-data/page-9",id:"turing-tako/complex-data/page-9",title:"Graphs",description:"Graphs are similar to trees infact all trees are graphs but all graphs are not trees. This is because graphs have two properties that trees do not. Firstly, they can have more than one arrow that lead into some nodes. Secondly, they can have arrows that lead back into themselves which we call cycles.",source:"@site/docs/turing-tako/complex-data/graphs.mdx",sourceDirName:"turing-tako/complex-data",slug:"/turing-tako/complex-data/page-9",permalink:"/NoTako/docs/turing-tako/complex-data/page-9",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/complex-data/graphs.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{id:"page-9",title:"Graphs",sidebar_position:9},sidebar:"turingSidebar",previous:{title:"Accumulators",permalink:"/NoTako/docs/turing-tako/complex-data/page-8"}},p={},m=[{value:"Directed Cyclic Graphs",id:"directed-cyclic-graphs",level:2},{value:"Shared",id:"shared",level:3},{value:"Data Definition",id:"data-definition",level:3},{value:"Template",id:"template",level:3},{value:"Reachable?",id:"reachable",level:2}],h={toc:m};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Graphs are similar to trees infact all trees are graphs but all graphs are not trees. This is because graphs have two properties that trees do not. Firstly, they can have more than one arrow that lead into some nodes. Secondly, they can have arrows that lead back into themselves which we call ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"cycles")),"."),(0,r.kt)("h2",{id:"directed-cyclic-graphs"},"Directed Cyclic Graphs"),(0,r.kt)("p",null,"Graphs come in many forms, they can be ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"directed"))," or ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"undirected")),". Directed graphs have arrows that point in a specific direction while undirected graphs have arrows that point in both directions. If the graph has cycles then it is called a ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"cyclic"))," graph, otherwise it is called an ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"acyclic"))," graph. We will be focusing on directed cyclic graphs in this section which are graphs that have arrows that point in a specific direction and have cycles."),(0,r.kt)(o.Z,{src:i,caption:"Directed Cyclic Graph",num:1,mdxType:"Fig"}),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"In Figure 1, there are many cycles in the graph including the cycle ",(0,r.kt)("inlineCode",{parentName:"p"},"1 -> 2 -> 4 -> 1")," and the cycle ",(0,r.kt)("inlineCode",{parentName:"p"},"3 -> 5 -> 1 -> 3"),". The graph is also directed because the arrows point in a specific direction.")),(0,r.kt)("h3",{id:"shared"},"Shared"),(0,r.kt)("p",null,"To be able to create cycles in our graphs, we need a new primitive called ",(0,r.kt)("inlineCode",{parentName:"p"},"shared")," because it allows us bind expressions to an id so that we can reference it later in the body."),(0,r.kt)("p",null,"The syntax for ",(0,r.kt)("inlineCode",{parentName:"p"},"shared")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"(shared ([<id> <expression>] ...) <body>)"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Shared Primitive" showLineNumbers',title:'"Shared','Primitive"':!0,showLineNumbers:!0},"(shared (-A- (cons 1 -B-))\n        (-B- 7)\n        -A-)\n\n; The above expression is equivalent to\n(cons 1 7)\n")),(0,r.kt)("h3",{id:"data-definition"},"Data Definition"),(0,r.kt)("p",null,"Now that we have the primitive ",(0,r.kt)("inlineCode",{parentName:"p"},"shared"),", we can create a data definition for graphs, one that is able to create cycles."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Data Definition" showLineNumbers',title:'"Data','Definition"':!0,showLineNumbers:!0},'(define-struct node (name exits))\n;; Node is (make-node String (listof Node))\n;; interp. a node\'s name, and list of nodes that the exit leads to\n\n; Only A leads to B\n(define N1 (make-node "A" (list (make-node "B" empty))))\n\n; A cycle between A and B\n(define N2 (shared ([-A- (make-node "A" (list -B-))]\n                    [-B- (make-node "B" (list -A-))])\n                   -A-))\n\n; A cycle between A, B, and C\n(define N3 (shared ([-A- (make-node "A" (list -B-))]\n                    [-B- (make-node "B" (list -C-))]\n                    [-C- (make-node "C" (list -A-))])\n                   -A-))\n\n; A more complex graph\n(define N4\n  (shared ([-A- (make-room "A" (list -B- -D-))]\n           [-B- (make-room "B" (list -C- -E-))]\n           [-C- (make-room "C" (list -B-))]\n           [-D- (make-room "D" (list -E-))]\n           [-E- (make-room "E" (list -F- -A-))]\n           [-F- (make-room "F" (list))])\n    -A-))\n')),(0,r.kt)(o.Z,{src:s,caption:"Drawing of Fourth Graph",num:2,mdxType:"Fig"}),(0,r.kt)("h3",{id:"template"},"Template"),(0,r.kt)("p",null,"Our template needs to be a blend of structural recursion that is encapsulated with local and is tail-recursive with a worklist. It also will need a context-preserving accumulator which keeps track of all the nodes we have already visited."),(0,r.kt)("p",null,"The template is similar to the template for an arbitrary tree except that we need to keep track of the nodes we have already visited so that we do not get stuck in a cycle which would cause our program to run forever."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Template" showLineNumbers',title:'"Template"',showLineNumbers:!0},"(define (fn-for-graph n0)\n  ;; todo is (listof Node) ; a worklist accumulator\n  ;; visited is (listof String) ; context preserving accumulator, names of rooms already visited\n  ;; ASSUME: Every node has an unique name\n  (local [(define (fn-for-node n todo visited)\n            (if (member (node-name n) visited)\n                (fn-for-lon todo visited)\n                (fn-for-lon (append (node-exits n) todo)\n                            (cons (node-name n) visited))))\n          (define (fn-for-lon todo visited)\n            (cond [(empty? todo) (...)]\n                  [else\n                   (fn-for-node (first todo)\n                                (rest todo)\n                                visited)]))]\n    (fn-for-node n0 empty empty)))\n")),(0,r.kt)("h2",{id:"reachable"},"Reachable?"),(0,r.kt)("p",null,"Let's use our template to create a function that determines if a node is reachable from another node. It could also be considered a function that determines if a node is in a graph."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Reachable" showLineNumbers',title:'"Reachable"',showLineNumbers:!0},';; Node String -> Boolean\n;; produce true if starting at n0 it is possible to reach a node with the name nme.\n#;\n(define (reachable? n0 nme) false) ; stub\n\n(check-expect (reachable? N1 "A") true)\n(check-expect (reachable? N1 "B") true)\n(check-expect (reachable? N1 "C") false)\n(check-expect (reachable? (first (node-exits N1)) "A") false)\n(check-expect (reachable? N4 "F") true)\n\n(define (reachable? n0 nme)\n  ;; todo is (listof Node) ; a worklist accumulator\n  ;; visited is (listof String) ; context preserving accumulator, names of nodes already visited\n  (local [(define (fn-for-node n todo visited)\n            (cond [(string=? (node-name n) nme) true]\n                  [(member (node-name n) visited) (fn-for-lon todo visited)]\n                  [else (fn-for-lon (append (node-exits n) todo)\n                                    (cons (node-name n) visited))]))\n          (define (fn-for-lon todo visited)\n            (cond [(empty? todo) false]\n                  [else\n                   (fn-for-node (first todo)\n                                (rest todo)\n                                visited)]))]\n    (fn-for-node n0 empty empty)))\n')))}u.isMDXComponent=!0}}]);