"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[4396],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>p});var i=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},s=Object.keys(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=i.createContext({}),c=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=c(e.components);return i.createElement(l.Provider,{value:n},e.children)},g={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,m=a(e,["components","mdxType","originalType","parentName"]),d=c(t),p=o,h=d["".concat(l,".").concat(p)]||d[p]||g[p]||s;return t?i.createElement(h,r(r({ref:n},m),{},{components:t})):i.createElement(h,r({ref:n},m))}));function p(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,r=new Array(s);r[0]=d;var a={};for(var l in n)hasOwnProperty.call(n,l)&&(a[l]=n[l]);a.originalType=e,a.mdxType="string"==typeof e?e:o,r[1]=a;for(var c=2;c<s;c++)r[c]=t[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4131:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=t(7462),o=(t(7294),t(3905));const s={id:"page-9",title:"Helper Functions",sidebar_position:9},r=void 0,a={unversionedId:"turing-tako/simple-data/page-9",id:"turing-tako/simple-data/page-9",title:"Helper Functions",description:"Functions have been getting more and more complex as we go along. A simple way to work with complexity is to break down the problem into smaller pieces. This is where helper functions come in, they help us break down problems into smaller more managable ones that we can solve and then put together to solve the bigger problem.",source:"@site/docs/turing-tako/simple-data/helpers.mdx",sourceDirName:"turing-tako/simple-data",slug:"/turing-tako/simple-data/page-9",permalink:"/NoTako/docs/turing-tako/simple-data/page-9",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/simple-data/helpers.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{id:"page-9",title:"Helper Functions",sidebar_position:9},sidebar:"turingSidebar",previous:{title:"Natural Numbers",permalink:"/NoTako/docs/turing-tako/simple-data/page-8"},next:{title:"Binary Search Tree",permalink:"/NoTako/docs/turing-tako/simple-data/page-10"}},l={},c=[{value:"Data Definition",id:"data-definition",level:2},{value:"Function Decomposition",id:"function-decomposition",level:2},{value:"Operating on Lists",id:"operating-on-lists",level:2},{value:"Domain Knowledge Shift",id:"domain-knowledge-shift",level:2},{value:"Finishing Up",id:"finishing-up",level:2},{value:"Complete Program",id:"complete-program",level:2}],m={toc:c};function g(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Functions have been getting more and more complex as we go along. A simple way to work with complexity is to break down the problem into smaller pieces. This is where helper functions come in, they help us break down problems into smaller more managable ones that we can solve and then put together to solve the bigger problem."),(0,o.kt)("p",null,"Let's tackle a problem where we get a list of images and we need to display the images left to right from smallest to largest."),(0,o.kt)("h2",{id:"data-definition"},"Data Definition"),(0,o.kt)("p",null,"Before we can start with any functions, we need a data definition for list of images. We already have images defined when we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"(require 2htdp/image)")," library so we just need to define a list of images."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Data Definition" showLineNumbers',title:'"Data','Definition"':!0,showLineNumbers:!0},'(require 2htdp/image)\n\n; ListOfImage is one of\n; - empty\n; - (cons Image ListOfImage)\n; interp. an arbitrary number of images\n\n(define LOS1 empty)\n(define LOS2 (cons (square 10 "solid" "white") empty))\n(define LOS3 (cons (square 20 "solid" "white") LOS2))\n\n#;\n(define (fn-for-loi loi)\n  (cond [(empty? loi) (...)]\n        [else (... (first loi)\n              (fn-for-loi (rest loi)))]))\n')),(0,o.kt)("h2",{id:"function-decomposition"},"Function Decomposition"),(0,o.kt)("p",null,"One common time we use helper functions is when the problem can be broken down into distinct parts where each part leads to the next. In this case, we have two distinct problems, one is to sort the list of images and once we have a sorted list, our second problem is to display the images left to right."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Function Decomposition" showLineNumbers',title:'"Function','Decomposition"':!0,showLineNumbers:!0},'; ListOfImage -> Image\n; Lay out images left to right in increasing order of size\n#;\n(define (arrange-images loi) BLANK) ;stub\n\n(check-expect (arrange-images (cons (rectangle 10 20 "solid" "blue")\n                                    (cons (rectangle 20 30 "solid" "red")\n                                          empty)))\n              (beside (rectangle 10 20 "solid" "blue")\n                      (rectangle 20 30 "solid" "red")\n                      BLANK))\n(check-expect (arrange-images (cons (rectangle 20 30 "solid" "red")\n                                    (cons (rectangle 10 20 "solid" "blue")\n                                          empty)))\n              (beside (rectangle 10 20 "solid" "blue")\n                      (rectangle 20 30 "solid" "red")\n                      BLANK))\n\n(define (arrange-images loi)\n  (layout-images (sort-images loi)))\n\n;; <---- WISHED FOR FUNCTIONS ----\x3e\n\n; ListOfImage -> Image\n; place images beside each other in order of list\n(define (layout-images loi) BLANK) ; stub\n\n; ListOfImage -> ListOfImage\n; sort images in increasing order of size (area)\n(define (sort-images loi) loi) ; stub\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Notice that we have wished for the functions ",(0,o.kt)("inlineCode",{parentName:"p"},"layout-images")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sort-images")," but we have not defined them yet. Even though they are not complete, we were able to define the function ",(0,o.kt)("inlineCode",{parentName:"p"},"arrange-images")," because we can assume that the functions we wish for will be able to do what we want them to do.")),(0,o.kt)("h2",{id:"operating-on-lists"},"Operating on Lists"),(0,o.kt)("p",null,"Another common time we use helper functions is when we need to operate on a list like how we need to operate on the list of images in order to sort it. To sort the list, we need to be able to traverse the list and be able to sort each element in the list one at a time. This is where a helper function can make a difference."),(0,o.kt)("p",null,"To sort the list, we will assume the last element in the list is already sorted and we will work backwards inserting each element into the right place in the sorted list till the whole list is sorted."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Sorting List" showLineNumbers',title:'"Sorting','List"':!0,showLineNumbers:!0},'; ListOfImage -> ListOfImage\n; sort images in increasing order of size (area)\n#;\n(define (sort-images loi) loi) ; stub\n\n(check-expect (sort-images empty) empty)\n(check-expect (sort-images (cons (rectangle 10 20 "solid" "blue")\n                                 (cons (rectangle 20 30 "solid" "red")\n                                       empty)))\n              (cons (rectangle 10 20 "solid" "blue")\n                                 (cons (rectangle 20 30 "solid" "red")\n                                       empty)))\n(check-expect (sort-images (cons (rectangle 20 30 "solid" "red")\n                                 (cons (rectangle 10 20 "solid" "blue")\n                                       empty)))\n              (cons (rectangle 10 20 "solid" "blue")\n                                 (cons (rectangle 20 30 "solid" "red")\n                                       empty)))\n(check-expect (sort-images (cons (rectangle 30 40 "solid" "green")\n                                 (cons (rectangle 20 30 "solid" "blue")\n                                       (cons (rectangle 10 20 "solid" "red")\n                                             empty))))\n              (cons (rectangle 10 20 "solid" "red")\n                    (cons (rectangle 20 30 "solid" "blue")\n                          (cons (rectangle 30 40 "solid" "green")\n                                empty))))\n\n(define (sort-images loi)\n  (cond [(empty? loi) empty] ; empty list is already sorted\n        [else\n         (insert (first loi) ; inserts each element into the right place\n              (sort-images (rest loi)))])) ; sorts the rest of the list\n')),(0,o.kt)("p",null,"Now we need to create the helper function ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," that we used in ",(0,o.kt)("inlineCode",{parentName:"p"},"sort-image"),". This function will insert the element into the sorted list."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Inserting Element into List" showLineNumbers',title:'"Inserting',Element:!0,into:!0,'List"':!0,showLineNumbers:!0},'; Image ListOfImage -> ListOfImage\n; insert image into list in increasing order of size (area)\n#;\n(define (insert img loi) loi) ; stub\n\n; Defined this to help with making tests\n(define I1 (rectangle 10 20 "solid" "blue"))\n(define I2 (rectangle 20 30 "solid" "red"))\n(define I3 (rectangle 30 40 "solid" "green"))\n\n(check-expect (insert I1 empty) (cons I1 empty))\n(check-expect (insert I1 (cons I2 (cons I3 empty))) (cons I1 (cons I2 (cons I3 empty))))\n(check-expect (insert I2 (cons I1 (cons I3 empty))) (cons I1 (cons I2 (cons I3 empty))))\n(check-expect (insert I3 (cons I1 (cons I2 empty))) (cons I1 (cons I2 (cons I3 empty))))\n\n(define (insert img loi)\n  (cond [(empty? loi) (cons img empty)] ; if list is empty, insert at front\n        [else (if (larger? img (first loi)) ; if image is larger than first element\n                  (cons (first loi) (insert img (rest loi))) ; insert image into rest of list\n              (cons img loi))])) ; else insert image at front\n')),(0,o.kt)("p",null,"One function deals with inserting elements while the other deals with going to every element in the list and making sure it is sorted. By breaking this complex task into two simpler tasks, we were able to solve the problem."),(0,o.kt)("h2",{id:"domain-knowledge-shift"},"Domain Knowledge Shift"),(0,o.kt)("p",null,"If you noticed, we used the function ",(0,o.kt)("inlineCode",{parentName:"p"},"larger?")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," but that function does not exist yet. In fact that is another helper function we will use. This is the third case where we commonly use helper functions. If we are looking to know something about the data that we do not already know, we can create a helper function to help us. In this case we don't know if one image is larger than another so we created a function to help us."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Comparing Images" showLineNumbers',title:'"Comparing','Images"':!0,showLineNumbers:!0},'; Image Image -> Boolean\n; is img1 larger than img2\n#;\n(define (larger? img1 img2) false) ; stub\n\n(check-expect (larger? (rectangle 3 4 "solid" "red") (rectangle 2 6 "solid" "red")) false)\n(check-expect (larger? (rectangle 5 4 "solid" "red") (rectangle 2 6 "solid" "red")) true)\n(check-expect (larger? (rectangle 3 5 "solid" "red") (rectangle 2 6 "solid" "red")) true)\n(check-expect (larger? (rectangle 3 4 "solid" "red") (rectangle 5 6 "solid" "red")) false)\n(check-expect (larger? (rectangle 3 4 "solid" "red") (rectangle 2 7 "solid" "red")) false)\n\n(define (larger? img1 img2)\n  (> (* (image-width img1) (image-height img1))\n     (* (image-width img2) (image-height img2))))\n')),(0,o.kt)("h2",{id:"finishing-up"},"Finishing Up"),(0,o.kt)("p",null,"Now that we have sorted the list, we just need to finish the function to render the image using the HTDF recipe and we are done."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Layout Images" showLineNumbers',title:'"Layout','Images"':!0,showLineNumbers:!0},'; ListOfImage -> Image\n; place images beside each other in order of list\n#;\n(define (layout-images loi) BLANK) ; stub\n\n(check-expect (layout-images empty) BLANK)\n(check-expect (layout-images (cons (rectangle 10 20 "solid" "blue")\n                                   (cons (rectangle 20 30 "solid" "red")\n                                         empty)))\n              (beside (rectangle 10 20 "solid" "blue")\n                      (rectangle 20 30 "solid" "red")\n                      BLANK))\n\n(define (layout-images loi)\n  (cond [(empty? loi) BLANK]\n        [else (beside (first loi)\n              (layout-images (rest loi)))]))\n')),(0,o.kt)("p",null,"Now the function ",(0,o.kt)("inlineCode",{parentName:"p"},"arrange-images")," because we were able to break the problem into smaller pieces and solve each piece individually. Any complex problem can be solved using theses techniques."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"One thing to note is a general rule of thumb besides the three cases we mentioned above is that each function should only do one thing. If you find yourself writing a function that does many things, you should break it up into smaller functions.")),(0,o.kt)("h2",{id:"complete-program"},"Complete Program"),(0,o.kt)("p",null,"Here is the complete program for ",(0,o.kt)("inlineCode",{parentName:"p"},"arrange-images"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Complete Program" showLineNumbers',title:'"Complete','Program"':!0,showLineNumbers:!0},'(require 2htdp/image)\n\n; ListOfImage is one of\n; - empty\n; - (cons Image ListOfImage)\n; interp. an arbitrary number of images\n\n(define LOS1 empty)\n(define LOS2 (cons (square 10 "solid" "white") empty))\n(define LOS3 (cons (square 20 "solid" "white") LOS2))\n\n#;\n(define (fn-for-loi loi)\n  (cond [(empty? loi) (...)]\n        [else (... (first loi)\n              (fn-for-loi (rest loi)))]))\n\n; ListOfImage -> Image\n; Lay out images left to right in increasing order of size\n#;\n(define (arrange-images loi) BLANK) ;stub\n\n(check-expect (arrange-images (cons (rectangle 10 20 "solid" "blue")\n                                    (cons (rectangle 20 30 "solid" "red")\n                                          empty)))\n              (beside (rectangle 10 20 "solid" "blue")\n                      (rectangle 20 30 "solid" "red")\n                      BLANK))\n(check-expect (arrange-images (cons (rectangle 20 30 "solid" "red")\n                                    (cons (rectangle 10 20 "solid" "blue")\n                                          empty)))\n              (beside (rectangle 10 20 "solid" "blue")\n                      (rectangle 20 30 "solid" "red")\n                      BLANK))\n\n(define (arrange-images loi)\n  (layout-images (sort-images loi)))\n\n\n; ListOfImage -> ListOfImage\n; sort images in increasing order of size (area)\n#;\n(define (sort-images loi) loi) ; stub\n\n(check-expect (sort-images empty) empty)\n(check-expect (sort-images (cons (rectangle 10 20 "solid" "blue")\n                                 (cons (rectangle 20 30 "solid" "red")\n                                       empty)))\n              (cons (rectangle 10 20 "solid" "blue")\n                                 (cons (rectangle 20 30 "solid" "red")\n                                       empty)))\n(check-expect (sort-images (cons (rectangle 20 30 "solid" "red")\n                                 (cons (rectangle 10 20 "solid" "blue")\n                                       empty)))\n              (cons (rectangle 10 20 "solid" "blue")\n                                 (cons (rectangle 20 30 "solid" "red")\n                                       empty)))\n(check-expect (sort-images (cons (rectangle 30 40 "solid" "green")\n                                 (cons (rectangle 20 30 "solid" "blue")\n                                       (cons (rectangle 10 20 "solid" "red")\n                                             empty))))\n              (cons (rectangle 10 20 "solid" "red")\n                    (cons (rectangle 20 30 "solid" "blue")\n                          (cons (rectangle 30 40 "solid" "green")\n                                empty))))\n\n(define (sort-images loi)\n  (cond [(empty? loi) empty] ; empty list is already sorted\n        [else\n         (insert (first loi) ; inserts each element into the right place\n              (sort-images (rest loi)))])) ; sorts the rest of the list\n\n\n; Image ListOfImage -> ListOfImage\n; insert image into list in increasing order of size (area)\n#;\n(define (insert img loi) loi) ; stub\n\n; Defined this to help with making tests\n(define I1 (rectangle 10 20 "solid" "blue"))\n(define I2 (rectangle 20 30 "solid" "red"))\n(define I3 (rectangle 30 40 "solid" "green"))\n\n(check-expect (insert I1 empty) (cons I1 empty))\n(check-expect (insert I1 (cons I2 (cons I3 empty))) (cons I1 (cons I2 (cons I3 empty))))\n(check-expect (insert I2 (cons I1 (cons I3 empty))) (cons I1 (cons I2 (cons I3 empty))))\n(check-expect (insert I3 (cons I1 (cons I2 empty))) (cons I1 (cons I2 (cons I3 empty))))\n\n(define (insert img loi)\n  (cond [(empty? loi) (cons img empty)] ; if list is empty, insert at front\n        [else (if (larger? img (first loi)) ; if image is larger than first element\n                  (cons (first loi) (insert img (rest loi))) ; insert image into rest of list\n              (cons img loi))])) ; else insert image at front\n\n\n; Image Image -> Boolean\n; is img1 larger than img2\n#;\n(define (larger? img1 img2) false) ; stub\n\n(check-expect (larger? (rectangle 3 4 "solid" "red") (rectangle 2 6 "solid" "red")) false)\n(check-expect (larger? (rectangle 5 4 "solid" "red") (rectangle 2 6 "solid" "red")) true)\n(check-expect (larger? (rectangle 3 5 "solid" "red") (rectangle 2 6 "solid" "red")) true)\n(check-expect (larger? (rectangle 3 4 "solid" "red") (rectangle 5 6 "solid" "red")) false)\n(check-expect (larger? (rectangle 3 4 "solid" "red") (rectangle 2 7 "solid" "red")) false)\n\n(define (larger? img1 img2)\n  (> (* (image-width img1) (image-height img1))\n     (* (image-width img2) (image-height img2))))\n\n\n; ListOfImage -> Image\n; place images beside each other in order of list\n#;\n(define (layout-images loi) BLANK) ; stub\n\n(check-expect (layout-images empty) BLANK)\n(check-expect (layout-images (cons (rectangle 10 20 "solid" "blue")\n                                   (cons (rectangle 20 30 "solid" "red")\n                                         empty)))\n              (beside (rectangle 10 20 "solid" "blue")\n                      (rectangle 20 30 "solid" "red")\n                      BLANK))\n\n(define (layout-images loi)\n  (cond [(empty? loi) BLANK]\n        [else (beside (first loi)\n              (layout-images (rest loi)))]))\n')))}g.isMDXComponent=!0}}]);