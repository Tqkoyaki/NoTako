"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[8665],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=i,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const o={id:"page-2",title:"How to Design Functions",sidebar_position:2},r=void 0,s={unversionedId:"turing-tako/simple-data/page-2",id:"turing-tako/simple-data/page-2",title:"How to Design Functions",description:"The how to design functions is a design method built to help with systematic design of functions. With well defined functions using this recipe, it eases the process of solving more complex problems.",source:"@site/docs/turing-tako/simple-data/htdf.mdx",sourceDirName:"turing-tako/simple-data",slug:"/turing-tako/simple-data/page-2",permalink:"/NoTako/docs/turing-tako/simple-data/page-2",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/simple-data/htdf.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"page-2",title:"How to Design Functions",sidebar_position:2},sidebar:"turingSidebar",previous:{title:"Beginner Student Language",permalink:"/NoTako/docs/turing-tako/simple-data/page-1"},next:{title:"How to Design Data",permalink:"/NoTako/docs/turing-tako/simple-data/page-3"}},l={},u=[{value:"The Recipe",id:"the-recipe",level:2},{value:"Signature, Purpose, and Stub",id:"signature-purpose-and-stub",level:3},{value:"Define Examples",id:"define-examples",level:3},{value:"Template and Inventory",id:"template-and-inventory",level:3},{value:"Code the Function Body",id:"code-the-function-body",level:3},{value:"Test and Debug Until Correct",id:"test-and-debug-until-correct",level:3},{value:"More Examples",id:"more-examples",level:2},{value:"Tall Images",id:"tall-images",level:3},{value:"Image Area",id:"image-area",level:3}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The how to design functions is a design method built to help with systematic design of functions. With well defined functions using this recipe, it eases the process of solving more complex problems."),(0,i.kt)("h2",{id:"the-recipe"},"The Recipe"),(0,i.kt)("p",null,"There are 5 steps to the recipe where each step builds onto the next one..."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Signature, purpose, and stub"),(0,i.kt)("li",{parentName:"ol"},"Define examples"),(0,i.kt)("li",{parentName:"ol"},"Template and inventory"),(0,i.kt)("li",{parentName:"ol"},"Code the function body"),(0,i.kt)("li",{parentName:"ol"},"Test and debug until correct")),(0,i.kt)("p",null,'The idea of the HtDF (How to Design Functions) recipe is to enable the idea of "run early and run often". Eliminating mistakes at each step of the recipe will help you to avoid mistakes later on in the process.'),(0,i.kt)("h3",{id:"signature-purpose-and-stub"},"Signature, Purpose, and Stub"),(0,i.kt)("p",null,"The signature of the function is defining the input and output types of the function. The purpose of the function is to define what the function does and the stub of the function is to define a syntactically correct function that does nothing."),(0,i.kt)("p",null,"Let's say the given problem is to write a function called double that consumes a number and produces twice the number..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Signature, Purpose, and Stub" showLineNumbers',title:'"Signature,',"Purpose,":!0,and:!0,'Stub"':!0,showLineNumbers:!0},"; The input is a number and the output is a number\n; Signature: Number -> Number\n\n; The purpose is what the function does\n; Purpose: Produce two times the input number\n\n; The stub is a syntactically correct function that does nothing\n(define (double n) 0) ; Stub\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We leave the stub uncommented so we can run the code and make sure there are no syntax errors. We will also use the stub for the next step.")),(0,i.kt)("h3",{id:"define-examples"},"Define Examples"),(0,i.kt)("p",null,"The next step is to define examples. For this we will use a new function called ",(0,i.kt)("inlineCode",{parentName:"p"},"check-expect"),". The syntax for ",(0,i.kt)("inlineCode",{parentName:"p"},"check-expect")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"(check-expect (function-name input) expected-output)"),". This allows us to test the function by providing examples of how the function should behave."),(0,i.kt)("p",null,"We want to have our examples cover many cases as possible. The signature from the double problem stated that the input is a number so we want to test decimal numbers, whole numbers, and negative numbers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Define Examples" showLineNumbers',title:'"Define','Examples"':!0,showLineNumbers:!0},"; Signature, Purpose, and Stub from above\n; Number -> Number\n; Produce two times the input number\n(define (double n) 0) ; Stub\n\n; Examples of how double should behave\n(check-expect (double 0) 0)\n(check-expect (double 1) 2)\n(check-expect (double 2.3) (* 2 2.3)) ; 2.3 * 2 = 4.6\n(check-expect (double -1) -2)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We can run the code at this point to see if there are no syntax errors. If there are syntax errors, we can fix them and run the code again. We expect the tests to fail at this point because we have not written the function yet.")),(0,i.kt)("h3",{id:"template-and-inventory"},"Template and Inventory"),(0,i.kt)("p",null,"The next step is to create a template and inventory. The template builds off the stub and replaces the default value with an expression that uses the input parameter (still does nothing). The template gives a clear sense of what the function has to work with. The inventory is creating all the constant values that would be useful to the function."),(0,i.kt)("p",null,"For the double function, there is no need for inventory because it requires no constants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Template and Inventory" showLineNumbers',title:'"Template',and:!0,'Inventory"':!0,showLineNumbers:!0},"; Number -> Number\n; Produce two times the input number\n#;\n(define (double n) 0) ; Stub\n\n(check-expect (double 0) 0)\n(check-expect (double 1) 2)\n(check-expect (double 2.3) (* 2 2.3))\n(check-expect (double -1) -2)\n\n; Template and Inventory\n(define (double n) \n    (... n))\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#;")," is a comment that comments out the next expression or definition. It is useful for commenting out the stub and the template. We cannot define a function twice so we comment out the stub and run the code to test if the template is correct.")),(0,i.kt)("h3",{id:"code-the-function-body"},"Code the Function Body"),(0,i.kt)("p",null,"Now that all the prep work is done, we can start to code the function body."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Code the Function Body" showLineNumbers',title:'"Code',the:!0,Function:!0,'Body"':!0,showLineNumbers:!0},"; Number -> Number\n; Produce two times the input number\n; (define (double n) 0)\n\n(check-expect (double 0) 0)\n(check-expect (double 1) 2)\n(check-expect (double 2.3) (* 2 2.3))\n(check-expect (double -1) -2)\n\n#;\n(define (double n) \n    (... n))\n\n; Code the function body\n(define (double n) \n    (* 2 n))\n")),(0,i.kt)("h3",{id:"test-and-debug-until-correct"},"Test and Debug Until Correct"),(0,i.kt)("p",null,"The last step is to test and debug until the function is correct. We know the function is correct when all the tests pass and if it does not, we use the error messages and the tests that failed to debug and fix the function."),(0,i.kt)("h2",{id:"more-examples"},"More Examples"),(0,i.kt)("p",null,"This recipe may feel overkill for these simple functions but it is useful for more complex functions later on."),(0,i.kt)("h3",{id:"tall-images"},"Tall Images"),(0,i.kt)("p",null,"The problem is to design a function that consumes an image and determine where the image is tall."),(0,i.kt)("p",null,"We will have many problems like this one where the problem is not well defined. Our goal is to have well defined purposes that overcome these problems. Let's define being tall as having a height that is greater than the width."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Tall Images" showLineNumbers',title:'"Tall','Images"':!0,showLineNumbers:!0},'(require 2htdp/image)\n\n; Image -> Boolean\n; Produce true if the image is tall\n; (define (tall? img) false)\n\n(check-expect (tall? (rectangle 10 20 "solid" "red")) true)\n(check-expect (tall? (rectangle 20 10 "solid" "red")) false)\n(check-expect (tall? (rectangle 10 10 "solid" "red")) true) # Note this test is bad\n\n#;\n(define (tall? img) \n    (... img))\n\n(define (tall? img) \n    (if (> (image-height img) (image-width img))\n        true\n        false))\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This would give us issues when we get to the test and debug step because a test would fail. A test failing means that the function definition could be wrong, the test could be wrong, or both are wrong. Always verify that the test is correct before debugging the function.")),(0,i.kt)("p",null,"Once the test is fixed, this is a well defined function that solves the problem but it can be improved. When we have an if statement that returns true if the condition is true and false if the condition is false, we can simplify the code by using the condition itself."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Tall Images" showLineNumbers',title:'"Tall','Images"':!0,showLineNumbers:!0},"; THIS IS...\n(define (tall? img) \n    (if (> (image-height img) (image-width img))\n        true\n        false))\n\n; THE SAME AS...\n(define (tall? img) \n    (> (image-height img) (image-width img)))\n")),(0,i.kt)("h3",{id:"image-area"},"Image Area"),(0,i.kt)("p",null,"The problem here is to design a function that consumes an image and produces the area of the image."),(0,i.kt)("p",null,"The one thing to note with this problem is that we can define the signature as ",(0,i.kt)("inlineCode",{parentName:"p"},"Image -> Number")," but it is not fully correct. We want our signatures to be specific as possible and images have pixels which are positive whole numbers so the area will always be positive whole numbers. So a more well defined signature is ",(0,i.kt)("inlineCode",{parentName:"p"},"Image -> Natural"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Image Area" showLineNumbers',title:'"Image','Area"':!0,showLineNumbers:!0},'; Image -> Natural\n; Produce the area of the image\n; (define (image-area img) 0)\n\n(check-expect (image-area (rectangle 10 20 "solid" "red")) (* 10 20))\n(check-expect (image-area (rectangle 20 10 "solid" "red")) (* 20 10))\n\n#;\n(define (image-area img) \n    (... img))\n\n(define (image-area img) \n    (* (image-width img) (image-height img)))\n')))}d.isMDXComponent=!0}}]);