"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[3769],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(f,o(o({ref:t},c),{},{components:n})):a.createElement(f,o({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1487:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={id:"page-4",title:"Abstraction",sidebar_position:4},o=void 0,l={unversionedId:"turing-tako/complex-data/page-4",id:"turing-tako/complex-data/page-4",title:"Abstraction",description:"Another technique commonly used in programming is abstraction, which is a technique that allows us to remove many pieces of repetitive code and refactoring out the identical parts. This kind of ability is useful for managing complexity in programs by making programs smaller.",source:"@site/docs/turing-tako/complex-data/abstraction.mdx",sourceDirName:"turing-tako/complex-data",slug:"/turing-tako/complex-data/page-4",permalink:"/NoTako/docs/turing-tako/complex-data/page-4",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/complex-data/abstraction.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"page-4",title:"Abstraction",sidebar_position:4},sidebar:"turingSidebar",previous:{title:"Encapsulation",permalink:"/NoTako/docs/turing-tako/complex-data/page-3"},next:{title:"Generative Recursion",permalink:"/NoTako/docs/turing-tako/complex-data/page-5"}},s={},p=[{value:"Parameterization",id:"parameterization",level:2},{value:"Higher Order Function",id:"higher-order-function",level:3},{value:"Built-in Function",id:"built-in-function",level:3},{value:"Closures",id:"closures",level:2},{value:"Fold Function",id:"fold-function",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Another technique commonly used in programming is ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"abstraction")),", which is a technique that allows us to remove many pieces of repetitive code and refactoring out the identical parts. This kind of ability is useful for managing complexity in programs by making programs smaller."),(0,i.kt)("h2",{id:"parameterization"},"Parameterization"),(0,i.kt)("p",null,"One way to ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"abstract"))," away repetitive code is to find functions that are similar and turn their differences into parameters keeping the internal logic mostly the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Simple Parameterization" showLineNumbers',title:'"Simple','Parameterization"':!0,showLineNumbers:!0},"; Getting the area of a circle\n(* pi (sqr 4))\n(* pi (sqr 6))\n(* pi (sqr 12))\n\n; Making the difference a parameter\n(define (area r)\n    (* pi (sqr r)))\n\n; New way to obtain area\n(area 4)\n(area 6)\n(area 12)\n")),(0,i.kt)("p",null,"The example above was a simple case where we wanted the area of various circles with different radius but the expression was mostly similar so we abstracted away the logic of area into a function and made the only thing different which was the radius into a parameter."),(0,i.kt)("p",null,"We can look at another example of functions that are similar. In this next case, we have two functions that are both searching for a string in a length. We can abstract the logic away."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Similar Functions" showLineNumbers',title:'"Similar','Functions"':!0,showLineNumbers:!0},';; ListOfString -> Boolean\n;; produce true if los includes "Italy"\n#;\n(define (contains-italy? los) false) ; stub\n\n\n(define (contains-italy? los) (contains? "Italy" los))\n  (cond [(empty? los) false]\n        [else\n         (if (string=? (first los) "Italy")\n             true\n             (contains-italy? (rest los)))])\n\n;; ListOfString -> Boolean\n;; produce true if los includes "Germany"\n#;\n(define (contains-germany? los) false) ; stub\n\n\n(define (contains-germany? los) (contains? "germany" los))\n  (cond [(empty? los) false]\n        [else\n         (if (string=? (first los) "germany")\n             true\n             (contains-italy? (rest los)))])\n')),(0,i.kt)("p",null,"In both cases, the only thing different about the functions is the string that is being checked so we can make it a parameter and redefine these functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Parameterization" showLineNumbers',title:'"Parameterization"',showLineNumbers:!0},';; String (listof String) -> Boolean\n;; produce true if los includes s\n\n(define (contains? s los)\n  (cond [(empty? los) false]\n        [else\n         (if (string=? (first los) s)\n             true\n             (contains? s (rest los)))]))\n\n; More concise definitions\n(define (contains-italy? los) (contains? "Italy" los))\n(define (contains-germany? los) (contains? "Germany" los))\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"On the note of abstraction, we can also abstract the data definition of lists. We can use a capital alphabetical letter to represent any data type. We can have a ",(0,i.kt)("inlineCode",{parentName:"p"},"(listof X)")," which refers to ",(0,i.kt)("inlineCode",{parentName:"p"},"ListOfX")," which is one of ",(0,i.kt)("inlineCode",{parentName:"p"},"empty")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"(cons X (listof X))"),". This allows us to use lists using one global and abstract definition that fits any datatype we want to use for our lists.")),(0,i.kt)("h3",{id:"higher-order-function"},"Higher Order Function"),(0,i.kt)("p",null,"What is cool about abstraction is that we can pass more than data as parameters. We can pass functions as well. If our function consumes or produces a different function, we call it a ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"higher order function")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Similar Functions" showLineNumbers',title:'"Similar','Functions"':!0,showLineNumbers:!0},";; (listof Number) -> (listof Number)\n;; produce list of sqr of every number in lon\n#;\n(define (squares lon) empty) ; stub\n\n(check-expect (squares empty) empty)\n(check-expect (squares (list 3 4)) (list 9 16))\n\n(define (squares lon)\n    (cond [(empty? lon) empty]\n    [else\n        (cons (sqr (first lon))\n            (squares (rest lon)))]))\n\n\n;; (listof Number) -> (listof Number)\n;; produce list of sqrt of every number in lon\n#;\n(define (square-roots lon) empty) ; stub\n\n(check-expect (square-roots empty) empty)\n(check-expect (square-roots (list 9 16)) (list 3 4))\n\n(define (square-roots lon)\n    (cond [(empty? lon) empty]\n    [else\n        (cons (sqrt (first lon))\n            (square-roots (rest lon)))]))\n")),(0,i.kt)("p",null,"Both those functions are very similar in functionality expect for the fact that one function uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"sqr")," function on ",(0,i.kt)("inlineCode",{parentName:"p"},"(first lon)")," and the other uses ",(0,i.kt)("inlineCode",{parentName:"p"},"sqrt"),". If we can pass these functions, the rest of the logic can stay the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Higher Order Function" showLineNumbers',title:'"Higher',Order:!0,'Function"':!0,showLineNumbers:!0},";; (X -> Y) (listof X) -> (listof Y)\n;; given fn and (list n0 n1 ...) produce (list (fn n0) (fn n1) ...)\n\n(define (map2 fn lon)\n  (cond [(empty? lon) empty]\n        [else\n         (cons (fn (first lon))\n               (map2 fn (rest lon)))]))\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We used capital alphabetical letters to signify that any datatype works for this case. The other thing to note is that in the signature there is another function signature, that refers to the signature of the function we are passing in. ",(0,i.kt)("inlineCode",{parentName:"p"},"X -> Y")," because the datatype consumed can be the same or different from the one produced in this case.")),(0,i.kt)("p",null,"Now that we have the higher order function, we can use it to simply our first two functions ",(0,i.kt)("inlineCode",{parentName:"p"},"squares")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"square-roots"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Simplification with Higher Order" showLineNumbers',title:'"Simplification',with:!0,Higher:!0,'Order"':!0,showLineNumbers:!0},"(define (squares lon)\n    (map2 sqr lon))\n\n(define (square-roots lon)\n    (map2 sqrt lon))\n")),(0,i.kt)("p",null,"In the signature of the abstract function called ",(0,i.kt)("inlineCode",{parentName:"p"},"map2")," we identified that the datatype that is consumed and produced can be anything showing it's flexibility."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Flexible Code" showLineNumbers',title:'"Flexible','Code"':!0,showLineNumbers:!0},';; (listof String) -> (listof Number)\n;; produces the lengths of all the strings in the list\n\n(define (lengths los)\n    (map2 string-length los))\n\n(lengths (list "a" "bc" "def")) ; produces (list 1 2 3)\n')),(0,i.kt)("h3",{id:"built-in-function"},"Built-in Function"),(0,i.kt)("p",null,"Flexible functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"map2")," allow us to write concise and clean code. It is great that there are already built in functions including ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," which does the same thing as our function ",(0,i.kt)("inlineCode",{parentName:"p"},"map2"),". These built in functions include..."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Signature"),(0,i.kt)("th",{parentName:"tr",align:null},"Purpose"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"map"),(0,i.kt)("td",{parentName:"tr",align:null},"(X -> Y) (listof X) -> (listof Y)"),(0,i.kt)("td",{parentName:"tr",align:null},"produces a list by applying f to each item on (listof x)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"build-list"),(0,i.kt)("td",{parentName:"tr",align:null},"Natural (Natural -> X) -> (listof X)"),(0,i.kt)("td",{parentName:"tr",align:null},"produces (list (f 0) ... (f (- n 1)))")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"filter"),(0,i.kt)("td",{parentName:"tr",align:null},"(X -> boolean) (listof X) -> (listof X)"),(0,i.kt)("td",{parentName:"tr",align:null},"produces a list from all items where (X -> boolean) produces true")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"andmap"),(0,i.kt)("td",{parentName:"tr",align:null},"(X -> boolean) (listof X) -> Boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"produces true if every element in list is true using (X -> boolean)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ormap"),(0,i.kt)("td",{parentName:"tr",align:null},"(X -> boolean) (listof X) -> Boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"produces true if one element in list is true using (X -> boolean)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"foldr"),(0,i.kt)("td",{parentName:"tr",align:null},"(X Y -> Y) Y (listof X) -> Y"),(0,i.kt)("td",{parentName:"tr",align:null},"(foldr f base (list x-1 ... x-n)) = (f x-1 ... (f x-n base))")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"foldl"),(0,i.kt)("td",{parentName:"tr",align:null},"(X Y -> Y) Y (listof X) -> Y"),(0,i.kt)("td",{parentName:"tr",align:null},"(foldr f base (list x-1 ... x-n)) = (f x-n ... (f x-1 base))")))),(0,i.kt)("p",null,"These functions are abstract so they are flexible in various situations. The examples below are only a few examples of these functions and their power."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Example of Filter" showLineNumbers',title:'"Example',of:!0,'Filter"':!0,showLineNumbers:!0},"(define (filter-neg lon)\n    (filter negative? lon))\n\n(filter-neg (list 1 -2 3 -4)) ; produces (list -2 -4)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Example of Foldr" showLineNumbers',title:'"Example',of:!0,'Foldr"':!0,showLineNumbers:!0},"(define (sum lon)\n    (foldr + 0 lon))\n\n(sum (list 1 2 3)) ; produces (+ 1 2 3 0)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Example of Build List" showLineNumbers',title:'"Example',of:!0,Build:!0,'List"':!0,showLineNumbers:!0},"(define (sqrd-list n)\n    (build-list n sqr))\n\n(sqrd-list 4) ; produces (list 0 1 4 9)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Another Example of Build List" showLineNumbers',title:'"Another',Example:!0,of:!0,Build:!0,'List"':!0,showLineNumbers:!0},"(define (seq n)\n    (build-list n identity))\n\n(seq 6) ; produces (list 0 1 2 3 4 5)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We used a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"identity")," when creating ",(0,i.kt)("inlineCode",{parentName:"p"},"seq")," and it produces the value it consumes. For example ",(0,i.kt)("inlineCode",{parentName:"p"},"(identity 3)")," produces ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," and ",(0,i.kt)("inlineCode",{parentName:"p"},'(identity "Dog")')," produces ",(0,i.kt)("inlineCode",{parentName:"p"},'"Dog"'),". This helps with ",(0,i.kt)("inlineCode",{parentName:"p"},"seq")," because the list is built using ",(0,i.kt)("inlineCode",{parentName:"p"},"(list (f 0) ... (f (- n 1)))")," so this creates ",(0,i.kt)("inlineCode",{parentName:"p"},"(list (identity 0) ... (identity (- n 1)))")," which in turn creates ",(0,i.kt)("inlineCode",{parentName:"p"},"(list 0 ... (- n 1))"),".")),(0,i.kt)("h2",{id:"closures"},"Closures"),(0,i.kt)("p",null,"Sometimes the function we want to pass needs to be coded but we only create it to pass it into an abstract function. This is where ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," comes in handy, we can define the function in ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," and then pass it into the abstract function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Local" showLineNumbers',title:'"Local"',showLineNumbers:!0},";; (listof Image) -> (listof Image)\n;; produces list of only those images that have width >= height\n#;\n(define (wide-only loi) empty) ; stub\n\n(check-expect (wide-only (list I1 I2 I3 I4 I5)) (list I2 I4))\n\n(define (wide-only loi)\n  (local [(define (wide? i)\n            (> (image-width i)\n               (image-height i)))]\n    (filter wide? loi)))\n")),(0,i.kt)("p",null,"We can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," for ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"closures"))," which is used when you want to pass a function whose body refers to a parameter that is in an outer function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Closures" showLineNumbers',title:'"Closures"',showLineNumbers:!0},"(define (wider-than-only w loi)\n  (local [(define (wider-than? i)\n            (> (image-width i) w))]\n    (filter wider-than? loi)))\n")),(0,i.kt)("p",null,"The parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," is in the outer function and can only be used in the abstract function ",(0,i.kt)("inlineCode",{parentName:"p"},"filter")," which does not take ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," as a parameter. By using ",(0,i.kt)("inlineCode",{parentName:"p"},"local")," we are able to create a temporary function with ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," that we can use in ",(0,i.kt)("inlineCode",{parentName:"p"},"filter"),". This is the power of closures!"),(0,i.kt)("h2",{id:"fold-function"},"Fold Function"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"fold function"))," is an abstract function that is based directly on the template (or templates like with mutual references) from the data definition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Data Definition" showLineNumbers',title:'"Data','Definition"':!0,showLineNumbers:!0},";; ListOfX also known as (listof X)\n;; - empty\n;; - (cons X (listof X))\n;; interp. a list of x\n\n;; the template is:\n(define (fn-for-lox lox)\n  (cond [(empty? lox) (...)]\n        [else\n         (... (first lox)\n              (fn-for-lox (rest lox)))]))\n")),(0,i.kt)("p",null,"Templates are great for creating abstract functions because we immediately know our parameters because every ",(0,i.kt)("inlineCode",{parentName:"p"},"...")," is a place we can replace with a parameter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Fold Function" showLineNumbers',title:'"Fold','Function"':!0,showLineNumbers:!0},';; (X Y -> Y) Y (listof X) -> Y\n;; the abstract fold function for (listof X)\n\n(check-expect (fold + 0 (list 1 2 3)) 6)\n(check-expect (fold * 1 (list 1 2 3)) 6)\n(check-expect (fold string-append "" (list "a" "bc" "def")) "abcdef")\n\n(define (fold fn b lox)\n  (cond [(empty? lox) b]\n        [else\n         (fn (first lox)\n              (fold fn b (rest lox)))]))\n')),(0,i.kt)("p",null,"This function is directly based on the template and can be used for every function that uses this datatype. So in case, this can be used for any list."))}u.isMDXComponent=!0}}]);