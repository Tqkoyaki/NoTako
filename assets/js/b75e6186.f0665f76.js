"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[8171],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?o.createElement(h,r(r({ref:t},u),{},{components:n})):o.createElement(h,r({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2313:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const i={id:"page-8",title:"Accumulators",sidebar_position:8},r=void 0,s={unversionedId:"turing-tako/complex-data/page-8",id:"turing-tako/complex-data/page-8",title:"Accumulators",description:"Structural recursion allow us to traverse complex data structures however it has its own limitation. Our functions are able to traverse data structures one at a time but they do not know what has been traversed or what is still left to be traversed. We basically know where we are, but we don't know where we've been or where we still need to go.",source:"@site/docs/turing-tako/complex-data/accumulators.mdx",sourceDirName:"turing-tako/complex-data",slug:"/turing-tako/complex-data/page-8",permalink:"/NoTako/docs/turing-tako/complex-data/page-8",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/complex-data/accumulators.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{id:"page-8",title:"Accumulators",sidebar_position:8},sidebar:"turingSidebar",previous:{title:"Sudoku",permalink:"/NoTako/docs/turing-tako/complex-data/page-7"},next:{title:"Graphs",permalink:"/NoTako/docs/turing-tako/complex-data/page-9"}},l={},c=[{value:"Design Recipe",id:"design-recipe",level:2},{value:"Context Preserving",id:"context-preserving",level:2},{value:"Tail Recursion",id:"tail-recursion",level:2},{value:"Worklist",id:"worklist",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Structural recursion allow us to traverse complex data structures however it has its own limitation. Our functions are able to traverse data structures one at a time but they do not know what has been traversed or what is still left to be traversed. We basically know where we are, but we don't know where we've been or where we still need to go."),(0,a.kt)("p",null,"This is where accumulators come in. Accumulators are a way to keep track of where we've been and where we still need to go. They are a way to keep track of the context of our traversal."),(0,a.kt)("h2",{id:"design-recipe"},"Design Recipe"),(0,a.kt)("p",null,"Before we can look at the different types of accumulators, we need to update our How to Design Functions recipe specifically the templating step."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-md",metastring:'title="How to Design Functions" showLineNumbers',title:'"How',to:!0,Design:!0,'Functions"':!0,showLineNumbers:!0},"1. Signature, purpose, stub\n2. Define examples, wrap each in check-expect\n3. Template and inventory\n   a. Template normally according to the rules for structural recursion\n   b. Encapsulate the template in an outer function using local\n   c. Add an accumulator parameter to the inner function\n4. Code the function body\n5. Test and debug until correct\n")),(0,a.kt)("p",null,"The only difference from the original recipe is the addition of the steps when templating a function. It is important to focus on this step to structure the function properly to make coding the body a lot easier."),(0,a.kt)("h2",{id:"context-preserving"},"Context Preserving"),(0,a.kt)("p",null,"There are three types of accumulators with the first being a context preserving accumulator. A context preserving accumulator allows us to keep track of information between recursive calls."),(0,a.kt)("p",null,"Let's create a function that will take a list of elements and skip every other positioned element to create a new list."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Skipping Elements" showLineNumbers',title:'"Skipping','Elements"':!0,showLineNumbers:!0},';; (listof X) -> (listof X)\n;; produce list consisting of only the 1st, 3rd, 5th... elements of lox\n#;\n(define (skip1 lox) empty) ; stub\n\n(check-expect (skip1 (list "a" "b" "c" "d")) (list "a" "c"))\n(check-expect (skip1 (list 1 2 3 4 5 6)) (list 1 3 5))\n\n; Templating without an accumulator\n(define (skip1 lox)\n  (cond [(empty? lox) (...)]\n        [else\n         (... (first lox)\n              (skip1 (rest lox)))]))\n\n; Encapsulate the template in an outer function using local\n(define (skip1 lox0)\n    (local [(define (skip1 lox)\n              (cond [(empty? lox) (...)]\n                    [else\n                     (... (first lox)\n                          (skip1 (rest lox)))]))]\n      (skip1 lox0)))\n\n; Add an accumulator parameter to the inner function\n(define (skip1 lox0)\n    (local [(define (skip1 lox acc)\n              (cond [(empty? lox) (...)]\n                    [else\n                     (... (first lox)\n                          (skip1 (rest lox) (...)))]))]\n      (skip1 lox0 ...)))\n')),(0,a.kt)("p",null,"Now that the template is complete, we can start figuring out how to use the accumulator. To skip every odd positioned element we need to know what position we are currently at. Normally, recursion doesn't know where it is at in the list, but with an accumulator we can keep track of the position."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Finishing Context Accumulator" showLineNumbers',title:'"Finishing',Context:!0,'Accumulator"':!0,showLineNumbers:!0},'; Add examples of the accumulator\n(define (skip1 lox0)\n    ;; acc: Natural; 1-based position of (first lox) in lox0\n    ;;\n    ;; (skip1 (list "a" "b" "c") 1)\n    ;; (skip1 (list     "b" "c") 2)\n    ;; (skip1 (list         "c") 3)\n    (local [(define (skip1 lox acc)\n              (cond [(empty? lox) (...)]\n                    [else\n                     (... (first lox)\n                          (skip1 (rest lox) (...)))]))]\n      (skip1 lox0 ...)))\n\n; Finish the function body\n(define (skip1 lox0)\n  ;; acc: Natural; 1-based position of (first lox) in lox0\n  ;;\n  ;; (skip1 (list "a" "b" "c") 1)\n  ;; (skip1 (list     "b" "c") 2)\n  ;; (skip1 (list         "c") 3)\n  (local [(define (skip1 lox acc)\n            (cond [(empty? lox) empty]\n                  [else\n                   (if (odd? acc)\n                        (cons (first lox)\n                              (skip1 (rest lox)\n                                     (add1 acc)))\n                        (skip1 (rest lox)\n                               (add1 acc)))]))]\n    (skip1 lox0 1)))\n')),(0,a.kt)("p",null,"The accumulator allowed us to keep track of the position of the element in the list which allowed us to determine if we should add the element to the new list or not. This would not be possible without the accumulator."),(0,a.kt)("h2",{id:"tail-recursion"},"Tail Recursion"),(0,a.kt)("p",null,"Tail recursion is a special type of function where every recursive call is in tail position. Tail position is where the recursive call is the last call in the function. This is important because it allows the function to be optimized by reducing the amount of stack frames needed to execute the function."),(0,a.kt)("p",null,"Let's create a function that sums up all the numbers in a list."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Summing a List" showLineNumbers',title:'"Summing',a:!0,'List"':!0,showLineNumbers:!0},";; (listof Number) -> Number\n;; sum up all the numbers in lon\n#;\n(define (sum lon) 0) ; stub\n\n(check-expect (sum empty) 0)\n(check-expect (sum (list 2 4 5)) 11)\n\n; This solution is not tail recursive\n(define (sum lon)\n  (cond [(empty? lon) 0]\n        [else\n         (+ (first lon)\n            (sum (rest lon)))]))\n")),(0,a.kt)("p",null,"With the solution above, we don't use accumulators and the recursive call at the end is not in tail position meaning this function can be optimized further. We know ",(0,a.kt)("inlineCode",{parentName:"p"},"(+ (first lon) (sum (rest lon)))")," is not in tail position because we are adding the result of the recursive call to the first element in the list. To be in tail position, the recursive call must be the last call in the function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Tail Recursive Sum" showLineNumbers',title:'"Tail',Recursive:!0,'Sum"':!0,showLineNumbers:!0},"(define (sum lon0)\n  ;; acc: Number; the sum of the elements of lon0 seen so far\n  ;; (sum (list 2 4 5))\n  ;; (sum (list 2 4 5) 0)\n  ;; (sum (list   4 5) 2)\n  ;; (sum (list     5) 6)\n  ;; (sum (list      ) 11)\n  (local [(define (sum lon acc)\n            (cond [(empty? lon) acc]\n                  [else\n                   (sum (rest lon)\n                        (+ acc (first lon)))]))] ; adding up on the way in instead of the way back out\n    (sum lon0 0)))\n")),(0,a.kt)("p",null,"The new solution uses ",(0,a.kt)("inlineCode",{parentName:"p"},"(sum (rest lon) (+ acc (first lon)))")," which is in tail position because the recursive call is the last call in the function and nothing is operating on the result of the recursive call."),(0,a.kt)("h2",{id:"worklist"},"Worklist"),(0,a.kt)("p",null,"The last type of accumulator is a worklist accumulator which can be useful for creating tail recursive solutions for problems that don't have a natural accumulator. A worklist accumulator is a list of elements that need to be processed. The accumulator is used to keep track of the work that needs to be done."),(0,a.kt)("p",null,"Let's create a function that will takes a key and a binary tree and returns true if the key is in the tree and false otherwise."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Searching a Binary Tree" showLineNumbers',title:'"Searching',a:!0,Binary:!0,'Tree"':!0,showLineNumbers:!0},'(define-struct node (k v l r))\n;; BT is one of:\n;;  - false\n;;  - (make-node Integer String BT BT)\n;; Interp. A binary tree, each node has a key, value and 2 children\n(define BT1 false)\n(define BT2 (make-node 1 "a"\n                       (make-node 6 "f"\n                                  (make-node 4 "d" false false)\n                                  false)\n                       (make-node 7 "g" false false)))\n\n\n;; Integer BT -> Boolean\n;; Produce true if the tree contains the given key\n(check-expect (contains? 1 BT1) false)\n(check-expect (contains? 1 BT2) true)\n(check-expect (contains? 3 BT2) false)\n(check-expect (contains? 7 BT2) true)\n\n(define (contains? k bt)\n  ;; todo: (listof BT); the list of so far univisited subtrees\n  (local [(define (contains/one? bt todo)\n            (cond [(false? bt) (contains/list? todo)]\n                  [else\n                   (if (= (node-k bt) k)\n                       true\n                       (contains/list? (cons (node-l bt)\n                                            (cons (node-r bt)\n                                                  todo))))]))\n          \n          (define (contains/list? todo)\n            (cond [(empty? todo) false]\n                  [else\n                   (contains/one? (first todo) (rest todo))]))]\n    \n    (contains/one? bt empty)))\n')),(0,a.kt)("p",null,"Here each node is placed into a worklist called ",(0,a.kt)("inlineCode",{parentName:"p"},"todo")," and is worked through one at a time. This allows us to process the tree in a tail recursive manner."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"One thing to note is when we are adding an accumulator to mutually recursive functions, we need add it to all the function.")))}p.isMDXComponent=!0}}]);