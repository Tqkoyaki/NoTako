"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[6803],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(t),h=i,d=m["".concat(l,".").concat(h)]||m[h]||c[h]||o;return t?a.createElement(d,r(r({ref:n},p),{},{components:t})):a.createElement(d,r({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3638:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=t(7462),i=(t(7294),t(3905));const o={id:"page-3",title:"Functions",sidebar_position:3},r=void 0,s={unversionedId:"turing-tako/prog-lang-a/page-3",id:"turing-tako/prog-lang-a/page-3",title:"Functions",description:"An important concept that functional programming languages share are first-class functions which are functions that can be computed, passed, stored, and more exactly like values. For example, we can pass functions as arguments to other functions, return them from other functions, put them in tuples, and more.",source:"@site/docs/turing-tako/prog-lang-a/functions.mdx",sourceDirName:"turing-tako/prog-lang-a",slug:"/turing-tako/prog-lang-a/page-3",permalink:"/NoTako/docs/turing-tako/prog-lang-a/page-3",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/prog-lang-a/functions.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"page-3",title:"Functions",sidebar_position:3},sidebar:"turingSidebar",previous:{title:"Compound Types",permalink:"/NoTako/docs/turing-tako/prog-lang-a/page-2"},next:{title:"Module System",permalink:"/NoTako/docs/turing-tako/prog-lang-a/page-4"}},l={},u=[{value:"Functions as Arguments",id:"functions-as-arguments",level:2},{value:"Polymorphic Types",id:"polymorphic-types",level:3},{value:"Anonymous Functions",id:"anonymous-functions",level:2},{value:"Unnecessary Function Wrapping",id:"unnecessary-function-wrapping",level:3},{value:"Hall of Fame Functions",id:"hall-of-fame-functions",level:2},{value:"Returning Functions",id:"returning-functions",level:2},{value:"First-Class Functions",id:"first-class-functions",level:3},{value:"Closures",id:"closures",level:2},{value:"Lexical Scope",id:"lexical-scope",level:3},{value:"Combining Function",id:"combining-function",level:2},{value:"Currying",id:"currying",level:2},{value:"Partial Application",id:"partial-application",level:3},{value:"Uncurrying",id:"uncurrying",level:3},{value:"Value Restriction",id:"value-restriction",level:3},{value:"Mutation",id:"mutation",level:2},{value:"Callbacks",id:"callbacks",level:3},{value:"Standard-Library Documentation",id:"standard-library-documentation",level:2}],p={toc:u};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An important concept that functional programming languages share are ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"first-class functions"))," which are functions that can be computed, passed, stored, and more exactly like values. For example, we can pass functions as arguments to other functions, return them from other functions, put them in tuples, and more."),(0,i.kt)("p",null,"With this characteristic, we can now better define ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"functional programming"))," which is general and is used to refer to several distinct concepts. Two concepts that appear in nearly all functional programming languages include:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The language avoids mutable data in most or all cases."),(0,i.kt)("li",{parentName:"ol"},"The language uses functions as values.")),(0,i.kt)("p",null,"There are also other common characteristic related to programming languages:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The language encourages recursion and recursive data structures."),(0,i.kt)("li",{parentName:"ol"},"The syntax or style of the language is closer to traditional mathematical definitions of functions.")),(0,i.kt)("h2",{id:"functions-as-arguments"},"Functions as Arguments"),(0,i.kt)("p",null,"As we have already discussed, functional languages like SML employ the concept of first class functions which allow functions to be passed as values. This means we can pass functions as arguments to other functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Functions as Arguments" showLineNumbers="true"',title:'"Functions',as:!0,'Arguments"':!0,showLineNumbers:'"true"'},"(* f is a function taken as an argument*)\nfun n_times (f, n, x) =\n    if n = 0\n    then x\n    else f (n_times (f, n - 1, x))\n\n(* Uses of n_times *)\nfun double x = 2 * x\nval n_1 = n_times (double, 4, 7) (* 112 *)\nval n_2 = n_times (tl, 2, [4,8,12,16]) (* [12,16] *)\n")),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"n_times")," takes ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," as an argument and then computes ",(0,i.kt)("inlineCode",{parentName:"p"},"f(f(...(f(x))))")," where the number of calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),". When we call ",(0,i.kt)("inlineCode",{parentName:"p"},"n_times (double, 4, 7)")," we are essentially calling ",(0,i.kt)("inlineCode",{parentName:"p"},"double(double(double(double 7)))"),". On the other hand, when we call ",(0,i.kt)("inlineCode",{parentName:"p"},"n_times (tl, 2, [4,8,12,16])")," we are essentially calling ",(0,i.kt)("inlineCode",{parentName:"p"},"tl(tl [4,8,12,16])"),"."),(0,i.kt)("p",null,"As we can see, we can take patterns that are common in many functions and abstract them away to get a more general and powerful functions that we can use to write other functions faster and cleaner."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"When functions either take functions as arguments or return other functions, we refer to them as ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"higher-order functions")),".")),(0,i.kt)("h3",{id:"polymorphic-types"},"Polymorphic Types"),(0,i.kt)("p",null,"SML employs a concept referred to ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"parametric polymorphic"))," or also ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"generic types")),". This is a concept which allows to create functions that take arguments of any type making them polymorphic. An example of this is ",(0,i.kt)("inlineCode",{parentName:"p"},"n_times")," which has the type ",(0,i.kt)("inlineCode",{parentName:"p"},"('a -> 'a) * int * 'a -> 'a"),". We were able to call it using the function ",(0,i.kt)("inlineCode",{parentName:"p"},"double")," which made the type ",(0,i.kt)("inlineCode",{parentName:"p"},"(int -> int) * int * int -> int")," and we were able to call it using the function ",(0,i.kt)("inlineCode",{parentName:"p"},"tl")," which made the call ",(0,i.kt)("inlineCode",{parentName:"p"},"(int list * int list) * int * int list -> int list"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Not all functions that take functions have polymorphic types. Vice versa there are functions with polymorphic types that do not take functions. Parametric polymorphic functions are just a special case of functions that take function and also are polymorphic.")),(0,i.kt)("h2",{id:"anonymous-functions"},"Anonymous Functions"),(0,i.kt)("p",null,"Sometimes we create functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"double")," for the sole purpose of passing them into other functions. The issue is that there is no reason to create the function at top level as it will only be used once. We could use let expressions to achieve this but SML has a better approach through the use of ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"anonymous functions"))," which are functions that have no name."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Anonymous Functions" showLineNumbers="true"',title:'"Anonymous','Functions"':!0,showLineNumbers:'"true"'},"(* Both double functions are equivalent *)\nfun double_1 x = 2 * x\nval double_2 = (fn x => 2 * x)\n\nval n_1 = n_times ((fn x => 2 * x), 4, 7) (* 112 *)\n")),(0,i.kt)("p",null,"The syntax for creating an anonymous function is ",(0,i.kt)("inlineCode",{parentName:"p"},"fn x => e")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is the argument and ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is the function expression using the argument. Note that the anonymous function is an expression and so we use val bindings instead of function bindings."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Anonymous functions would be syntactic sugar for function bindings however as anonymous functions have no name, we are unable to call them inside themselves. This means anonymous functions cannot do recursion but function bindings can.")),(0,i.kt)("h3",{id:"unnecessary-function-wrapping"},"Unnecessary Function Wrapping"),(0,i.kt)("p",null,"There is a common poor idiom used with anonymous functions that should be avoid. Given a function ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", we could create an anonymous function ",(0,i.kt)("inlineCode",{parentName:"p"},"fn x => g x")," which takes an input and calls ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," with it. This works perfectly fine but is equivalent to just writing ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Unnessary Function Wrapping" showLineNumbers="true"',title:'"Unnessary',Function:!0,'Wrapping"':!0,showLineNumbers:'"true"'},"(* poor style *)\nval n_1 = n_times ((fn x => tl x), 2, [4,8,12,16]) (* [12,16] *)\n\n(* good style *)\nval n_2 = n_times (tl, 2, [4,8,12,16]) (* [12,16] *)\n")),(0,i.kt)("h2",{id:"hall-of-fame-functions"},"Hall of Fame Functions"),(0,i.kt)("p",null,"There are quite a few higher-order functions that are incredibly important idioms that we often use in many programming languages. The ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," function takes a list and a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and applies the function to every element of the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Map" showLineNumbers="true"',title:'"Map"',showLineNumbers:'"true"'},"(* Type: ('a -> 'b) * 'a list -> 'b list *)\nfun map (f, xs) = \n    case xs of\n        [] => []\n      | x::xs' => (f x)::(map(f, xs'))\n\n(* Examples *)\nval x1 = map(hd, [[1,2],[3,4],[5,6,7]]) (* [1,3,5] *)\nval x2 = map(fn x => x + 1, [4,8,12,16]) (* [5,9,13,17] *)\n")),(0,i.kt)("p",null,"As we can see map can change the type of the resulting expression based on what the function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," outputs. The next function is ",(0,i.kt)("inlineCode",{parentName:"p"},"filter")," which takes a function that returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," and it creates a new list with only the elements that make the function ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". This essentially lets us filter elements out of a list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Filter" showLineNumbers="true"',title:'"Filter"',showLineNumbers:'"true"'},"(* Type: ('a -> bool) * 'a list -> 'a list  *)\nfun filter (f, xs) =\n    case xs of\n        [] => []\n      | x::xs' => if f x\n                  then x::(filter(f, xs'))\n                  else filter(f, xs')\n\n(* Examples *)\nval x1 = filter((fn v => v > 5), [2,3,4,5,6,7]) (* [6,7] *)\nval x2 = filter((fn v => v mod 2 = 0), [2,3,4,5,6,7]) (* [2,4,6] *)\n")),(0,i.kt)("p",null,"The next function is ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," which takes an initial answer ",(0,i.kt)("inlineCode",{parentName:"p"},"acc")," and uses ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," to combine ",(0,i.kt)("inlineCode",{parentName:"p"},"acc")," by folding over it. Essentially, given a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and a list ",(0,i.kt)("inlineCode",{parentName:"p"},"[x1, x2, ..., xn]"),", we get the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"f(xn, ..., f(x2, f(x1, init))...)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Fold" showLineNumbers="true"',title:'"Fold"',showLineNumbers:'"true"'},"(* Type: ('a * 'b -> 'b) * 'b * 'a list -> 'b *)\nfun fold (f, acc, xs) =\n    case xs of\n        [] => acc\n      | x::xs' => fold(f, f(acc,x), xs')\n\n(* Examples *)\n(* Sum of list *)\nval x1 = fold((fn (x, y) => x + y), 0, [1,2,3,4,5]) (* 15 *)\n\n(* Strings shorter than 3*)\nval x2 = fold((fn (x, y) => x andalso String.size y < 3), true, [\"hi\", \"bye\"]) (* false *)\n")),(0,i.kt)("p",null,"The final function we will look at is ",(0,i.kt)("inlineCode",{parentName:"p"},"exists")," which returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if a function at any point returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Exists" showLineNumbers="true"',title:'"Exists"',showLineNumbers:'"true"'},"(* Type: ('a -> bool) * 'a list -> bool *)\nfun exists (f, xs) =\n    case xs of\n        [] => false\n      | x::xs' => (f x) orelse (exists (f, xs'))\n\n(* Examples *)\nval x1 = exists ((fn x => x = 1), [5,4,3,2,1]) (* true *)\nval x2 = exists ((fn x => x mod 2 = 0), [1,3,5,7,9]) (* false *)\n")),(0,i.kt)("p",null,"There are more common higher-order functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"inject")," but the idea is the same with all these functions. We essentially divide the work of any function into two parts: the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"implementer"))," knows how to traverse a data structure while the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"client"))," knows what to do do with the data there. The four functions (",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"filter"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"fold"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"exists"),") are all implementers that any client can use with their data."),(0,i.kt)("h2",{id:"returning-functions"},"Returning Functions"),(0,i.kt)("p",null,"We have created higher-order functions that take functions as arguments but we can also return functions as well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Returning Functions" showLineNumbers="true"',title:'"Returning','Functions"':!0,showLineNumbers:'"true"'},"(* Type: (int -> bool) -> (int -> int) *)\nfun double_or_triple f =\n    if f ~1\n    then fn x => 2 * x\n    else fn y => 3 * x\n")),(0,i.kt)("p",null,"When ML prints the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"double_or_triple"),", it prints ",(0,i.kt)("inlineCode",{parentName:"p"},"(int -> bool) -> int -> int")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"->")," associates to the right in ML. So, ",(0,i.kt)("inlineCode",{parentName:"p"},"tl -> (t2 -> (t3 -> t4))")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"t1 -> t2 -> t3 -> t4")," making the paranthesis unnecessary."),(0,i.kt)("h3",{id:"first-class-functions"},"First-Class Functions"),(0,i.kt)("p",null,"As previously stated, first-class functions mean that functions can be treated as values. This means all constructs that use values can take in functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="First-Class Functions" showLineNumbers="true"',title:'"First-Class','Functions"':!0,showLineNumbers:'"true"'},"datatype exp = Constant of int\n             | Negate of exp\n             | Add of exp * exp\n             | Multiply of exp * exp\n\nfun true_of_all_constants(f, e) =\n    case e of\n        Constant i => f i\n      | Negate e1 => true_of_all_constants(f,e1)\n      | Add(e1,e2) => true_of_all_constants(f,e1) andalso true_of_all_constants(f,e2)\n      | Multiply(e1,e2) => true_of_all_constants(f,e1) andalso true_of_all_constants(f,e2)\n\nfun all_even e = true_of_all_constants(fn x => x mod 2 = 0, e)\n")),(0,i.kt)("p",null,"In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"true_of_all_constants")," is also a higher-order function because it takes in a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,i.kt)("h2",{id:"closures"},"Closures"),(0,i.kt)("p",null,"Functions are able to use any bindings that are in scope and by combing this with higher-order functions is very powerful. As previously discussed, due to lexical scope, the body of a function is evaluated in the environment where the function is defined, not where the function is called. This means the value of a function has two parts, the code of the function and the environment that was current when we created the function."),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"function closure"))," or just ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"closure"))," is the pair of code and environment of any given function. The closure carries with it an environment that provides all the bindings for the function and so the closure overall has everything it needs to produce a function result given a function argument."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Closures" showLineNumbers="true"',title:'"Closures"',showLineNumbers:'"true"'},"fun allGreaterThan (xs, n) = filter (fn x => x > n, xs)\n\nfun allShorterThan(xs, s) =\n    let\n        val i = String.size s\n    in\n        filter(fn x => String.size x < i, xs)\n    end\n")),(0,i.kt)("p",null,"In both ",(0,i.kt)("inlineCode",{parentName:"p"},"allGreaterThan")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"allShorterThan"),", we introduce new bindings that we can use in functions we are passing into higher-order functions allowing us to create more general functions. This is only possible due to closures."),(0,i.kt)("h3",{id:"lexical-scope"},"Lexical Scope"),(0,i.kt)("p",null,"Lexical scope means that the function uses the environment during the creation of the function. However, ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"dynamic scope"))," uses the environment during the calling of the function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Scope" showLineNumbers="true"',title:'"Scope"',showLineNumbers:'"true"'},"val x = 0\n\nfun f y = x + y\n\nval x = 5\nf(3)\n")),(0,i.kt)("p",null,"When we call ",(0,i.kt)("inlineCode",{parentName:"p"},"f(3)")," we get ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," due to lexical scope. If it was dynamic scope, the result would be ",(0,i.kt)("inlineCode",{parentName:"p"},"8")," because we changed the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," before we called ",(0,i.kt)("inlineCode",{parentName:"p"},"f(3)"),". The issue with dynamic scope is that we have to be more worried the names of variables in all levels of scope which is why most programming languages use lexical scope for things like variables."),(0,i.kt)("p",null,"There are compelling uses for dynamic scope for certain idioms and so some languages do have support for dynamic scope. In fact, exceptions in ML behave more like dynamic scope than lexical scope because when an exception is raised, the evaluation looks for which handle expression to evaluate by using the dynamic call stack which chooses the handle expression closest to the call with no regard to the lexical structure of the program."),(0,i.kt)("h2",{id:"combining-function"},"Combining Function"),(0,i.kt)("p",null,"Often when we are programming, it is useful to create new functions that are a combination of other functions. The composition of the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"f(g(x))"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Function Composition" showLineNumbers="true"',title:'"Function','Composition"':!0,showLineNumbers:'"true"'},"fun compose (f,g) = fn x => f (g x)\n")),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"compose")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"('a -> 'b) * ('c -> 'a) -> 'c -> 'b")," because our resulting function is the input type of ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," and the output type of ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,i.kt)("p",null,"There are two operators that SML provides us in order to combine function. The first infix operator is ",(0,i.kt)("inlineCode",{parentName:"p"},"o")," (lowercase o) which allows us to combine functions without using paranthesis. The other operator is the pipeline operator which we define using the ",(0,i.kt)("inlineCode",{parentName:"p"},"infix")," keyword. We often use ",(0,i.kt)("inlineCode",{parentName:"p"},"infix |>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"infix !>")," which works just like ",(0,i.kt)("inlineCode",{parentName:"p"},"o")," but in reverse."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Composition Operators" showLineNumbers="true"',title:'"Composition','Operators"':!0,showLineNumbers:'"true"'},"(* All the following bindings are equivalent *)\nfun sqrt_of_abs i = Math.sqrt(Real.fromInt(abs i))\n\nfun sqrt_of_abs i = (Math.sqrt o Real.fromInt o abs) i\n\nval sqrt_of_abs = Math.sqrt o Real.fromInt o abs\n\ninfix |>\n\nfun sqrt_of_abs i = i |> abs |> Real.fromInt |> Math.sqrt\n\nval sqrt_of_abs = abs |> Real.fromInt |> Math.sqrt\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"There is often an error when using ",(0,i.kt)("inlineCode",{parentName:"p"},"|>")," on Emacs but is fine if we use ",(0,i.kt)("inlineCode",{parentName:"p"},"infix !>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!>")," instead.")),(0,i.kt)("h2",{id:"currying"},"Currying"),(0,i.kt)("p",null,"So far for multi-argument functions, we have been passing a tuple into the function. However, another clever and often convenient approach is to have a function take the first conceptual argument and return another function that takes the second conceptual argument and so on. This technique is called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"currying"))," and is named after Haskell Curry who studied related ideas to this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Currying" showLineNumbers="true"',title:'"Currying"',showLineNumbers:'"true"'},"(* Type: int -> int -> int -> bool *)\nval sorted_3_curry = fn x => fn y => fn z => z >= y andalso y >= x\n\n(* Type: (int * int * int) -> bool *)\nfun sorted_3_tupled (x,y,z) = z >= y andalso y >= x\n\n(* Calling these functions *)\nval x1 = sorted_3_curry 4 5 6 (* true *)\nval x2 = sorted_3_tupled (4,5,6) (* true *)\n")),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"sorted_3_curry")," is a function that returns an argument that takes ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and returns a function that takes ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," which returns a function that takes ",(0,i.kt)("inlineCode",{parentName:"p"},"z"),". Note that we can create curried functions with any number of arguments."),(0,i.kt)("p",null,"When we are calling a curried function, we seperate each argument using a space instead of putting them all in a tuple. This distinction is important because we are essentially calling each function seperately with its own argument. In general, the syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"e1 e2 e3 e4 ...")," is implicitly the nested function calls ",(0,i.kt)("inlineCode",{parentName:"p"},"((((e1 e2) e3) e4) ...)")," and this choice was made because it makes using a curried function more pleasant."),(0,i.kt)("p",null,"ML encourages curried function so there is syntactic sugar which makes writing curried functions easier..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Curried Function Syntactic Sugar" showLineNumbers="true"',title:'"Curried',Function:!0,Syntactic:!0,'Sugar"':!0,showLineNumbers:'"true"'},"(* The following two functions are equivalent *)\n(* Type: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b *)\nfun fold f = fn acc => fn xs =>\n    case xs of\n        [] => acc\n      | x::xs' => fold f (f(acc,x)) xs'\n\nfun fold f acc xs =\n    case xs of\n        [] => acc\n      | x::xs' => fold f (f(acc,x)) xs'\n")),(0,i.kt)("p",null,"By seperating each argument using spaces allows us to create curried functions more conveniently."),(0,i.kt)("h3",{id:"partial-application"},"Partial Application"),(0,i.kt)("p",null,"The biggest benefit of using curried functions is ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"partial application"))," which is when we only provide a subset of the conceptual arguments to get an argument that only needs the remaining arguments. This makes these higher-order functions more flexible and is only possible due to closures."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Partial Application" showLineNumbers="true"',title:'"Partial','Application"':!0,showLineNumbers:'"true"'},"(* Type: int -> int -> int list *)\nfun range i j = if i > j then [] else i :: range (i+1) j\n\n(* Type: int -> int list *)\nval countup = range 1\n")),(0,i.kt)("p",null,"To create ",(0,i.kt)("inlineCode",{parentName:"p"},"countup"),", we only provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," argument so this new function only takes in ",(0,i.kt)("inlineCode",{parentName:"p"},"j")," and counts up from ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),". This is only possible due to currying. Due to this convenient feature of currying, ML implements most functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"filter"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"exists"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," (which is written as ",(0,i.kt)("inlineCode",{parentName:"p"},"foldl"),") in curried form."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In terms of efficiency between currying and tupling, they are nearly equivalent so it doesn't really matter. They work proportionally to the number of conceptual arguments which is typically small."),(0,i.kt)("p",{parentName:"admonition"},"However, for ML tupling seems to be slightly faster. On the other hand, programming languages like OCaml, Haskell, and F#, curried functions seem to be faster. It is essentially depended on the programming language but for most case its barely a difference.")),(0,i.kt)("h3",{id:"uncurrying"},"Uncurrying"),(0,i.kt)("p",null,"We are able to combine functions to take a function from curried form to tupled form and from tupled form to curried form."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Uncurrying" showLineNumbers="true"',title:'"Uncurrying"',showLineNumbers:'"true"'},"(* Swaps the order of the arguments *)\n(* Type: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c *)\nfun swap_arguments f x y = f y x\n\n(* Changes between forms *)\n(* Type: ('a * 'b -> 'c) -> 'a -> 'b -> 'c *)\nfun curry f x y = f (x, y)\n\n(* Type: ('a -> 'b -> 'c) -> 'a * 'b -> 'c *)\nfun uncurry f (x, y) = f x y\n")),(0,i.kt)("p",null,"Looking at the types, if we consider ",(0,i.kt)("inlineCode",{parentName:"p"},"->")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"implies")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"and"),", then the types of all these functions are logical tautologies. "),(0,i.kt)("h3",{id:"value-restriction"},"Value Restriction"),(0,i.kt)("p",null,"There are still limitations with currying and partial applications. We can try to use it to create a polymorphic function but certains uses of this will not work in ML. Theoretically, they should but we end up getting a ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"value restriction"))," error."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Value Restriction" showLineNumbers="true"',title:'"Value','Restriction"':!0,showLineNumbers:'"true"'},"(* Both these functions raise Value Restriction *)\n(* turns [v1, ..., vn] into [SOME v1, ..., SOME vn] *)\nval mapSome = List.map SOME\n\n(* turns [v1, ..., vn] into [(v1, v2), ..., (vn, vn)] *)\nval pairIt = List.map (fn x => (x, x))\n")),(0,i.kt)("p",null,"Value restriction is essentially because without it the type-checker might allow some code to break the type system. This can only happen with code that is using mutation and even though the code above does not do that, the type-checker does not known this fact. To fix this issue, we can replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"val")," binding with a ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," binding or add a restriction to the types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Value Restriction Solution" showLineNumbers="true"',title:'"Value',Restriction:!0,'Solution"':!0,showLineNumbers:'"true"'},"(* Both these functions work *)\n(* Turned into a fun binding to fix *)\nfun mapSome xs = List.map SOME xs\n\n(* Restricted types to fix *)\nval pairIt: int list -> (int * int) list = List.map (fn x => (x, x))\n")),(0,i.kt)("h2",{id:"mutation"},"Mutation"),(0,i.kt)("p",null,'Mutation is not the default for ML and functional programs in general but ML does provide support for mutation. Even with all the drawbacks with mutation, it is useful in some situations. One situation in functional programming is to use mutation only when "updating the state of something so all users of that state can see a change has occurred".'),(0,i.kt)("p",null,"Most things in ML cannot be mutated so we need to create a ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"reference"))," which is a container whose contents can be changed."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"To create a ref we use ",(0,i.kt)("inlineCode",{parentName:"li"},"ref e")," and give us ",(0,i.kt)("inlineCode",{parentName:"li"},"t ref")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," is the type of ",(0,i.kt)("inlineCode",{parentName:"li"},"e"),"."),(0,i.kt)("li",{parentName:"ol"},"To get the contents inside the container, we use ",(0,i.kt)("inlineCode",{parentName:"li"},"!r")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"r")," is the reference. The type of ",(0,i.kt)("inlineCode",{parentName:"li"},"r")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"t ref")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"!r")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),"."),(0,i.kt)("li",{parentName:"ol"},"To update the contains of ",(0,i.kt)("inlineCode",{parentName:"li"},"r")," we use ",(0,i.kt)("inlineCode",{parentName:"li"},"r := e"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Mutation" showLineNumbers="true"',title:'"Mutation"',showLineNumbers:'"true"'},"(* Type: int ref *)\nval x = ref 0\n\n(* Type: int ref *)\nval y = x\n\n(* Type: int *)\nval z = !x\n\n(* Changes the contents of x *)\nx := 5\n\nans = (!y) + 2 (* 7 *)\n")),(0,i.kt)("p",null,"The result of ",(0,i.kt)("inlineCode",{parentName:"p"},"ans")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"7")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," because due to mutation ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," refer to the same container. So when we changed the value in ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", we essentially changed ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,i.kt)("h3",{id:"callbacks"},"Callbacks"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Callbacks")),' are a powerful idiom used in many libraries. Consider a library that detects when "events" occur like a user pressing a key, a user moving their mouse, data arriving from a network interface, and etc. When such an event occurs, the library informs its clients that have previously "registered" their interest in these events which is done when a client provides a ',(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"callback"))," which is a function that gets called when the event occurs. Note that these libraries allow multiple clients to register callbacks."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Callback Example" showLineNumbers="true"',title:'"Callback','Example"':!0,showLineNumbers:'"true"'},'(* Holds a list of callbacks *)\nval cbs : (int -> unit) list ref = ref []\n\n(* Clients call this to register their callback *)\nfun onKeyEvent f = cbs := f::(!cbs)\n\n(* The function is called when a key is pressed *)\n(* The int value is a code for what key is pressed *)\nfun onEvent i =\n    let fun loop fs =\n        case fs of\n            [] => ()\n          | f::fs\' => (f i; loop fs\')\n    in loop (!cbs) end\n\n(* Function to register callbacks *)\nfun printIfPressed i =\n    onKeyEvent (fn j => if i = j\n                        then print ("you pressed " ^ Int.toString i ^ "\\n")\n                        else ())\n\n(* Registers a callback for when the key associated with 4 is pressed *)\nval _ = printIfPressed 4\n\n(* Registers a callback for when the key associated with 11 is pressed *)\nval _ = printIfPressed 11\n')),(0,i.kt)("p",null,"In the example above, the ",(0,i.kt)("inlineCode",{parentName:"p"},"onEvent")," is the function that gets called when a key is pressed and so it essentially detects the event. The expression inside the event calls all the callbacks stored in ",(0,i.kt)("inlineCode",{parentName:"p"},"cbs"),". Finally, we created a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"printIfPressed")," which took in a key value and registed a callback to ",(0,i.kt)("inlineCode",{parentName:"p"},"onKeyEvent")," which prints a statement if the key is pressed. We were able to use this function to register two callbacks that printed a statement if ",(0,i.kt)("inlineCode",{parentName:"p"},"4")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"11")," were pressed."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"When we use ",(0,i.kt)("inlineCode",{parentName:"p"},"e1;e2")," like with ",(0,i.kt)("inlineCode",{parentName:"p"},"f i; loop fs'"),", ML evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"e1")," then throws away the result and then does ",(0,i.kt)("inlineCode",{parentName:"p"},"e2")," and returns that result."),(0,i.kt)("p",{parentName:"admonition"},"Also, when we do ",(0,i.kt)("inlineCode",{parentName:"p"},"val _ = e")," like with ",(0,i.kt)("inlineCode",{parentName:"p"},"val _ = printIfPressed 4"),", ML evalutes ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," but it does not bind to any variable.")),(0,i.kt)("h2",{id:"standard-library-documentation"},"Standard-Library Documentation"),(0,i.kt)("p",null,"Many languages like ML have a ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"standard library"))," which is a collection of predefined functions that the users of the programming language can use. Typically these standard libraries serve two purposes..."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'The standard library lets us interface with the "outside world" to provide features like opening a file or setting a timer which would otherwise be impossible to implement. '),(0,i.kt)("li",{parentName:"ol"},"The standary library implements super common and useful functions like concatenating two strings, mapping over a list, etc.")),(0,i.kt)("p",null,"Standard libraries are typically extremely large so programmers should seek out the documentation over memorizing the entire library. The programmer can use this documentation to find functions that may be useful to use in their code. For ML, the documentation can be found at (",(0,i.kt)("a",{parentName:"p",href:"https://www.standardml.org/Basis/manpages.html"},"https://www.standardml.org/Basis/manpages.html"),")."),(0,i.kt)("p",null,"To use a function in ML, you use the syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"structure.function")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"structure")," is the module where the function is located like ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," while ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," is the name of the function. Examples of this include ",(0,i.kt)("inlineCode",{parentName:"p"},"List.map"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"List.filter"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Char.isUpper"),"."),(0,i.kt)("p",null,"Finally, we can list all the function names and their types for a given structure in the REPL by following the example below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="REPL Example" showLineNumbers="true"',title:'"REPL','Example"':!0,showLineNumbers:'"true"'},"(* We want to know about the List structure *)\nstructure X = List;\n\n(* The REPL prints this out *)\nstructure X : LIST\n\n(* We write LIST because that is what the REPL stated *)\nsignature X = LIST;\n\n(* The REPL prints a list of all the functions in List *)\n")))}c.isMDXComponent=!0}}]);