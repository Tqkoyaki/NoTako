"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[799],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var a=o.createContext({}),h=function(e){var t=o.useContext(a),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=h(e.components);return o.createElement(a.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=h(n),p=i,m=d["".concat(a,".").concat(p)]||d[p]||u[p]||r;return n?o.createElement(m,s(s({ref:t},c),{},{components:n})):o.createElement(m,s({ref:t},c))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=d;var l={};for(var a in t)hasOwnProperty.call(t,a)&&(l[a]=t[a]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var h=2;h<r;h++)s[h]=n[h];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2253:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>h});var o=n(7462),i=(n(7294),n(3905));const r={id:"page-10",title:"Searching and Sorting",sidebar_position:10},s=void 0,l={unversionedId:"turing-tako/intro-to-cs/page-10",id:"turing-tako/intro-to-cs/page-10",title:"Searching and Sorting",description:"There are many times one needs to sort collections and search them as well. The collections we may run these algorithms on may be huge and we need to make sure we pick efficient solution to problems.",source:"@site/docs/turing-tako/intro-to-cs/searchsort.mdx",sourceDirName:"turing-tako/intro-to-cs",slug:"/turing-tako/intro-to-cs/page-10",permalink:"/NoTako/docs/turing-tako/intro-to-cs/page-10",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/intro-to-cs/searchsort.mdx",tags:[],version:"current",sidebarPosition:10,frontMatter:{id:"page-10",title:"Searching and Sorting",sidebar_position:10},sidebar:"turingSidebar",previous:{title:"Program Efficiency",permalink:"/NoTako/docs/turing-tako/intro-to-cs/page-9"}},a={},h=[{value:"Searching",id:"searching",level:2},{value:"Linear Search",id:"linear-search",level:3},{value:"Bisection Search",id:"bisection-search",level:3},{value:"Sorting",id:"sorting",level:2},{value:"Monkey Sort (Bogosort)",id:"monkey-sort-bogosort",level:3},{value:"Bubble Sort",id:"bubble-sort",level:3},{value:"Selection Sort",id:"selection-sort",level:3},{value:"Merge Sort",id:"merge-sort",level:3}],c={toc:h};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There are many times one needs to sort collections and search them as well. The collections we may run these algorithms on may be huge and we need to make sure we pick efficient solution to problems."),(0,i.kt)("h2",{id:"searching"},"Searching"),(0,i.kt)("p",null,"Searching algorithms are methods for finding an item or group of items with specific properties within a collection of items."),(0,i.kt)("h3",{id:"linear-search"},"Linear Search"),(0,i.kt)("p",null,"Linear search is where you look through each element in a list in order till you find the element you are looking for."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Linear Search" showLineNumbers',title:'"Linear','Search"':!0,showLineNumbers:!0},"def search(L, e):\n    # Loop through whole list\n    for i in range(len(L)):\n        # Check if the element is found\n        if L[i] == e:\n            return True\n    # The element does not exist\n    return False\n")),(0,i.kt)("p",null,"The worst case scenario is that the element does not exist so you loop through the list once and don't find the element so the complexity is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)"),"."),(0,i.kt)("h3",{id:"bisection-search"},"Bisection Search"),(0,i.kt)("p",null,"The other type of search is bisection search which can only be used if the list is sorted. It finds the middle of the list and checks if that element is the element that we are looking for. If it is not, we check if the element is greater than or less than the element we are looking for and based on that we can eliminate half the list where the element cannot exist in. We know it does not exist because the list is sorted."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Bisection Search" showLineNumbers',title:'"Bisection','Search"':!0,showLineNumbers:!0},"def bisect_search(L, e):\n    if len(L) == 0: # Base case\n        return False\n    else:\n        return bisect_search_helper(L, e, 0, len(L) - 1)\n\ndef bisect_search_helper(L, e, low, high):\n    if high == low: # Base case is the whole list is cleared\n        return L[low] == e\n    \n    # Finds the midpoint\n    mid = (low + high) // 2\n\n    # Check if the element is the midpoint\n    if L[mid] == e:\n        return True\n    # Checks if element is bigger than midpoint\n    elif L[mid] > e:\n        # Nothing left to search\n        if low == mid:\n            return False\n        else:\n            # Removes the higher half\n            return bisect_search_helper(L, e, low, mid - 1)\n    else:\n        # Remotes the top half\n        return bisect_search_helper(L, e, mid + 1, high)\n")),(0,i.kt)("p",null,"Each time this algorithm reduces the problem by half by eliminating half of the list. Due to this, the complexity is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(log n)"),". This is much faster than linear search but it requires the list to be sorted."),(0,i.kt)("h2",{id:"sorting"},"Sorting"),(0,i.kt)("p",null,"Sorting algorithms help organize the list which can then be used to search faster with bisection sort. It is not valuable to sort and then search once because the fastest a sorting algorithm can be is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)")," because every element needs to be checked at least once. So, if you are sorting to use bisection search. It is better to only sort if you are going to search that list multiple times."),(0,i.kt)("h3",{id:"monkey-sort-bogosort"},"Monkey Sort (Bogosort)"),(0,i.kt)("p",null,"This is where you randomly organize the list and then go through the list to check if it is sorted. If it is not sorted, you randomly organize the list again."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Monkey Sort" showLineNumbers',title:'"Monkey','Sort"':!0,showLineNumbers:!0},"def monkey_sort(L):\n    # Checks if the list is sorted\n    while not is_sorted(L):\n        # Randomly organizes the list\n        random.shuffle(L)\n")),(0,i.kt)("p",null,"The best case is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)")," and this only happens if you get lucky and the list gets sorted first try. If randomly it is sorted, you still need to loop through the list once to check if the list is sorted. The worst case is ",(0,i.kt)("inlineCode",{parentName:"p"},"unbounded")," because there is no definite number of times the algorithm can take to sort the list because of the random aspect to it."),(0,i.kt)("h3",{id:"bubble-sort"},"Bubble Sort"),(0,i.kt)("p",null,"Bubble sort is where you check consecutive pairs and swap them if they are unsorted. You keep looping through the list till everything is sorted. The end of the list gets sorted first and you work backwards to the front of the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Bubble Sort" showLineNumbers',title:'"Bubble','Sort"':!0,showLineNumbers:!0},"def bubble_sort(L):\n    swap = False\n    # As long as we have swapped at least once, we are not sorted\n    while not swap:\n        # Reset swap\n        swap = True\n        # Loop through the list\n        for i in range(1, len(L)):\n            # Checks if previous is greater than the current (meaning unsorted)\n            if L[i - 1] > L[i]:\n                # A swap has occured so the list is not sorted\n                swap = False\n                \n                # Swaps the elements to sort it\n                L[i - 1], L[i] = L[i], L[i - 1]\n")),(0,i.kt)("p",null,"The while loop has a complexity of ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)")," and the for loop also has a complexity of ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)"),". Due to the fact they are nested, you multiply them to get the complexity of bubble sort which is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n^2)"),"."),(0,i.kt)("h3",{id:"selection-sort"},"Selection Sort"),(0,i.kt)("p",null,"Selection sort is where you loop through the list and find the minimum element and swap it with the first element of the unsorted list. Once that is done, that part of the list is sorted. You then extract the second minimum element and replace it with the second element in the list. You keep repeating this till all of the list is sorted. Unlike bubble sort, you are sorting from left to right instead of right to left."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Selection Sort" showLineNumbers',title:'"Selection','Sort"':!0,showLineNumbers:!0},"def selection_sort(L):\n    sorted_len = 0\n    # Loops through the list as long as the list is not sorted\n    while sorted_len != len(L):\n        # Loops through unsorted portion of list\n        for i in range(sorted_len, len(L)):\n            # Checks if the current element is smaller than the element we are sorting\n            if L[i] < L[sorted_len]:\n                # Swaps the element\n                L[sorted_len], L[i] = L[i], L[sorted_len]\n        # Increments size of sorted list\n        sorted_len += 1\n")),(0,i.kt)("p",null,"There are also two loops that are nested in selection sort. The while loop has a complexity of ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)")," and the second loop also has a worst case of ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)"),". Due to the fact that they are nested, you get a complexity of ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n^2)"),"."),(0,i.kt)("h3",{id:"merge-sort"},"Merge Sort"),(0,i.kt)("p",null,"Not every sorting algorithm is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n^2)"),". We can do better with merge sort which has the best worst case complexity for sorting because it uses a divide and conquer approach. If the list is of size 0 or 1, we consider it sorted. So we take longer lists and split them into two smaller lists and sort them. Once each smaller list is sorted, we merge them back by sorting the smaller lists into bigger sorted lists."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Merge Sort" showLineNumbers',title:'"Merge','Sort"':!0,showLineNumbers:!0},"def merge_sort(L):\n    if len(L) < 2: # Base Case (Sorted)\n        return L\n    else:\n        # Midpoint found to split list into two smaller lists\n        middle = len(L) // 2\n\n        # Splits the list\n        left = merge_sort(L[:middle])\n        right = merge_sort(L[middle:])\n\n        # Merges the sorted list\n        return merge(left, right)\n\ndef merge(left, right):\n    # Holds the result\n    result = []\n    # For indexing\n    i, j = 0, 0\n\n    # As long as there are elements left any list\n    while i < len(left) and j < len(right):\n        # Checks if left is smaller\n        if left[i] < right[j]:\n            # Adds left to sorted list because it is smaller\n            result.append(left[i])\n            # Looks at next element in list\n            i += 1\n        else:\n            # Adds right because it is smaller\n            result.append(right[j])\n            j += 1\n        \n        # Adds all the elements that are left in the smaller lists\n        # We can do this because the smaller lists are sorted and one list is empty now\n        while(i < len(left)):\n            result.append(left[i])\n            i += 1\n        while(j < len(right)):\n            result.append(right[i])\n            j += 1\n        \n        # Merge complete\n        return result\n")),(0,i.kt)("p",null,"At each recursive level you are looping through the list one time so that is a ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)")," complexity. You are also dividing the list in half during each call so this takes ",(0,i.kt)("inlineCode",{parentName:"p"},"O(log n)"),". When you multiply them, you get the overall complexity of ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n log(n))")," which is faster than ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n^2)"),"."))}u.isMDXComponent=!0}}]);