"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[7805],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),l=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),h=l(a),d=i,u=h["".concat(p,".").concat(d)]||h[d]||c[d]||s;return a?n.createElement(u,r(r({ref:t},m),{},{components:a})):n.createElement(u,r({ref:t},m))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,r=new Array(s);r[0]=h;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var l=2;l<s;l++)r[l]=a[l];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},6558:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=a(7462),i=(a(7294),a(3905));const s={id:"page-2",title:"Compound Types",sidebar_position:2},r=void 0,o={unversionedId:"turing-tako/prog-lang-a/page-2",id:"turing-tako/prog-lang-a/page-2",title:"Compound Types",description:"Programming languages have base types like int, bool, and unit which are the simplest types in the language. They are types that cannot be broken down into smaller types. All other types in the language use other types in their definition which are called compound types. By using compound types, the language can contain fairly small number of base types and still be able to represent a wide variety of data.",source:"@site/docs/turing-tako/prog-lang-a/compound.mdx",sourceDirName:"turing-tako/prog-lang-a",slug:"/turing-tako/prog-lang-a/page-2",permalink:"/NoTako/docs/turing-tako/prog-lang-a/page-2",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/prog-lang-a/compound.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"page-2",title:"Compound Types",sidebar_position:2},sidebar:"turingSidebar",previous:{title:"Programming in ML",permalink:"/NoTako/docs/turing-tako/prog-lang-a/page-1"},next:{title:"Week 3",permalink:"/NoTako/docs/turing-tako/prog-lang-a/page-3"}},p={},l=[{value:"Records",id:"records",level:2},{value:"Redefining Tuples",id:"redefining-tuples",level:3},{value:"Datatype Bindings",id:"datatype-bindings",level:2},{value:"Case Expressions",id:"case-expressions",level:3},{value:"Lists and Options",id:"lists-and-options",level:3},{value:"Polymorphic Datatypes",id:"polymorphic-datatypes",level:3},{value:"Type Synonyms",id:"type-synonyms",level:2},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Type Inference",id:"type-inference",level:3},{value:"Variable Bindings",id:"variable-bindings",level:3},{value:"Polymorphism",id:"polymorphism",level:2},{value:"Nested Patterns",id:"nested-patterns",level:3},{value:"Multi Case Functions",id:"multi-case-functions",level:2},{value:"Exceptions",id:"exceptions",level:2},{value:"Tail Recursion",id:"tail-recursion",level:2},{value:"Efficiency",id:"efficiency",level:3},{value:"Tail Position",id:"tail-position",level:3}],m={toc:l};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Programming languages have ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"base types"))," like ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," which are the simplest types in the language. They are types that cannot be broken down into smaller types. All other types in the language use other types in their definition which are called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"compound types")),". By using compound types, the language can contain fairly small number of base types and still be able to represent a wide variety of data."),(0,i.kt)("p",null,"We can categorize compound types into three building blocks that are used to build them:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"Each-of"')," is a compound type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," which contains values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"t2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"li"},"tn"),". Tuples are an example of this type because you can have a tuple which contains multiple values in one type."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"One-of"')," is a compound type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," which contains values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"t2"),", ..., or ",(0,i.kt)("inlineCode",{parentName:"li"},"tn"),". Options are an example of this type because it can either be ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"Some t")," but not both."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"Self-Reference"')," is a compound type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," which may refer to itself in its definition to describe a recursive data structure. Lists are an example of this type because how a list is defined is that it is either ",(0,i.kt)("inlineCode",{parentName:"li"},"[]")," or contains a value (which is the head of the list) and another list (which is the tail of the list). Due to the fact it contains another list, it is self-referential.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'These three building blocks are not mutually exclusive. In fact, a list is a combination of all three building blocks. It uses "each-of" because it contains a value ',(0,i.kt)("strong",{parentName:"p"},"and"),' another list. It uses "one-of" because it can either be ',(0,i.kt)("inlineCode",{parentName:"p"},"[]"),' or contain a value and another list. Finally, it uses "self-reference" because it contains another list in its definition.')),(0,i.kt)("h2",{id:"records"},"Records"),(0,i.kt)("p",null,'Records are a new "each-of" type where each value in the type is labeled with a name. The syntax for records is:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Record Syntax" showLineNumbers="true"',title:'"Record','Syntax"':!0,showLineNumbers:'"true"'},"(* Creating a Record *)\n{field1 = value1, field2 = value2, ..., fieldn = valuen}\n\n(* Accessing a Record *)\n#field record\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"field1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"field2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"fieldn")," are the non-repeating names of the fields and ",(0,i.kt)("inlineCode",{parentName:"p"},"value1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"value2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"valuen")," are the values of the fields. The fields can be in any order and the values can be any type. We can also access the values of the fields in a record using the ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," operator. In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"field")," is the name of the field and ",(0,i.kt)("inlineCode",{parentName:"p"},"record")," is the record. With these syntaxes, we can work with records in SML. We can see an example of this below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Record Example" showLineNumbers="true"',title:'"Record','Example"':!0,showLineNumbers:'"true"'},'(* Creating a Record *)\nval person = {name = "John", age = 20, height = 5.8}\n\n(* Accessing a Record *)\nval name = #name person\nval age = #age person\nval height = #height person\n')),(0,i.kt)("h3",{id:"redefining-tuples"},"Redefining Tuples"),(0,i.kt)("p",null,"As you have already noticed, there are similarities between records and tuples. In fact, tuples are just a special case of records. We can redefine tuples using records as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Tuple Redefinition" showLineNumbers="true"',title:'"Tuple','Redefinition"':!0,showLineNumbers:'"true"'},"(* Tuple Syntax *)\ntuple = (v1, v2, ..., vn)\n\n(* Tuple as Record *)\ntuple_record = {1 = v1, 2 = v2, ..., n = vn}\n\n(* Accessing Both *)\n#1 tuple (* v1 *)\n#1 tuple_record (* v1 *)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"v1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"v2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"vn")," are the values of the tuple. As you can see, all the behaviors of tuples are preserved in this new definition. In fact, a tuple was made to be convenient way to write down and use records. When a construct in a language can be defined in terms of another construct, it is called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"syntactic sugar")),". In this case, tuples are syntactic sugar for records. As we can see with tuples, this concept is a great way to keep the key ideas in a language small while giving programmers convenient ways to use them."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Often when designing a language construct or choosing which one to use, we come across the question whether we should store and access the values by name or by position. In this case, records store and access the values by name while tuples store and access the values by position."),(0,i.kt)("p",{parentName:"admonition"},"Typically, by position is simplier for a small number of components, but for larger compound types it becomes too difficult to remember which position corresponds to which value and so it is better to use names in that case.")),(0,i.kt)("h2",{id:"datatype-bindings"},"Datatype Bindings"),(0,i.kt)("p",null,'We can also create our own "one-of" types using the new ',(0,i.kt)("inlineCode",{parentName:"p"},"datatype")," keyword. This keyword lets us create a new type that contains multiple constructors which are the different options of the type. An example of this is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Datatypes" showLineNumbers="true"',title:'"Datatypes"',showLineNumbers:'"true"'},"(* Defining a New Datatype *)\ndatatype rank = Jack |\n                Queen |\n                King |\n                Ace |\n                Num of int\n\n(* Creating a Value of the Datatype *)\nval card_1 = Jack\nval card_2 = Ace\nval card_3 = Num 8 \n")),(0,i.kt)("p",null,"where a new type ",(0,i.kt)("inlineCode",{parentName:"p"},"rank")," is created which has five constructors (options) that represent the different ranks of a card. The last constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"Num")," uses a new keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," which allows us to store a value of another type in the constructor. In this case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Num")," constructor stores an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," which represents the number of the card. "),(0,i.kt)("p",null,"We are able to create values of this new type by using the constructors and if the constructor can store a value, we can provide it as an argument to the constructor. The precise syntax for a datatype is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Datatype Syntax" showLineNumbers="true"',title:'"Datatype','Syntax"':!0,showLineNumbers:'"true"'},"(* Defining a New Datatype *)\ndatatype t = C1 of t1 | C2 of t2 | ... | Cn of tn\n\n(* Creating a Value of the Datatype *)\nval v = C1 v1\nval v = C1 (* if of is omitted *)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," is the name of the datatype, ",(0,i.kt)("inlineCode",{parentName:"p"},"C1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"C2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"Cn")," are the names of the constructors, and ",(0,i.kt)("inlineCode",{parentName:"p"},"t1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"tn")," are the types of the values that the constructors can store. We can also omit the ",(0,i.kt)("inlineCode",{parentName:"p"},"of"),' keyword which indicates that the variant of the datatype "carries nothing".'),(0,i.kt)("p",null,'Finally, due to the fact that constructors can store values of any type, we can combine "one-of" with "self-reference" by referring to the datatype itself in the definition of the datatype. This allows us to create recursive data structures. An example of this is:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Recursive Datatype" showLineNumbers="true"',title:'"Recursive','Datatype"':!0,showLineNumbers:'"true"'},"datatype exp = Constant of int\n             | Negate of exp\n             | Add of exp * exp\n             | Multiply of exp * exp\n")),(0,i.kt)("p",null,"where the ",(0,i.kt)("inlineCode",{parentName:"p"},"exp")," datatype is referenced in the constructs ",(0,i.kt)("inlineCode",{parentName:"p"},"Negate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Add"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Multiply"),". This allows us to create expressions like ",(0,i.kt)("inlineCode",{parentName:"p"},"Add (Constant 1, Multiply (Constant 2, Constant 3))")," which represents the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"1 + 2 * 3"),"."),(0,i.kt)("h3",{id:"case-expressions"},"Case Expressions"),(0,i.kt)("p",null,"When working with datatypes, we need to be able to write code that handles all variants of the datatype as well as extract the values stored in the constructors. Thankfully, SML provides a way to do both of these things using ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," expressions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Case Expressions" showLineNumbers="true"',title:'"Case','Expressions"':!0,showLineNumbers:'"true"'},'(* Case Expression Syntax *)\ncase e of p1 => e1 | p2 => e2 | ... | pn => en\n\n(* Case Expression Example *)\n(* Converts a Card Rank to a String *)\ncase card_rank of\n    Jack => "Jack"\n    | Queen => "Queen"\n    | King => "King"\n    | Ace => "Ace"\n    | Num n => Int.toString n\n')),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is the expression we are matching on, ",(0,i.kt)("inlineCode",{parentName:"p"},"p1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"p2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"pn")," are the patterns we are matching against, and ",(0,i.kt)("inlineCode",{parentName:"p"},"e1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"e2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"en")," are the expressions of the same type that are evaluated and returned if the pattern matches. In the case of the example, all the expressions are strings."),(0,i.kt)("p",null,"A pattern is a construct we have not seen before. Patterns look like expressions but instead are used to match against the result of evaluating ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),". This idea is called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"pattern matching")),". The patterns used in the case expression are the various constructors that are matched against the result of evaluating ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),". In the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"Num n"),", If the constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"Num")," is matched, then the value stored in the constructor is bound to the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," which can be used in the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"Int.toString n"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="More Examples" showLineNumbers="true"',title:'"More','Examples"':!0,showLineNumbers:'"true"'},"(* Case Expression Example *)\n(* Evaluates the exp Datatype *)\nfun eval e =\n    case e of\n        Constant n => n\n        | Negate e => ~ (eval e)\n        | Add (e1, e2) => (eval e1) + (eval e2)\n        | Multiply (e1, e2) => (eval e1) * (eval e2)\n\neval (Add (Constant 1, Multiply (Constant 2, Constant 3))) (* 7 *)\neval (Negate (Add (Constant 1, Multiply (Constant 2, Constant 3)))) (* ~7 *)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"If a constructor stores a tuple, we can use a pattern to seperate the values of the tuple into variables like ",(0,i.kt)("inlineCode",{parentName:"p"},"Add (e1, e2)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Multiply (e1, e2)")," in the example above.")),(0,i.kt)("p",null,"This idea of pattern matching and case expressions is very powerful because..."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"It makes sure we handled all the cases of a datatype (the complier will warn us if we don't)."),(0,i.kt)("li",{parentName:"ol"},"It prevents us from repeating variants (The complier will warn us if we do)."),(0,i.kt)("li",{parentName:"ol"},"It allows us to extract the values stored in the constructors."),(0,i.kt)("li",{parentName:"ol"},"It is general enough to allow us to write complex code in a simple way.")),(0,i.kt)("h3",{id:"lists-and-options"},"Lists and Options"),(0,i.kt)("p",null,"Datatypes and case expressions are very powerful and general enough to allow us to create many different types. In fact, lists and options are just datatypes that are defined in the SML library and we can redefine them ourselves."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="List and Option Redefined" showLineNumbers="true"',title:'"List',and:!0,Option:!0,'Redefined"':!0,showLineNumbers:'"true"'},"(* List Datatype *)\ndatatype int_list = Empty |\n                    Cons of int * int_list\n\nval empty_list = Empty (* [] *)\nval list_1 = Cons (1, Cons (2, Cons (3, Empty))) (* [1, 2, 3] *)\n\n(* Option Datatype *)\ndatatype int_option = None | Some of int\n\nval none = None (* NONE *)\nval some_1 = Some 1 (* SOME 1 *)\n")),(0,i.kt)("p",null,"We can even redefine functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"append")," to work with our new list datatype. Those functions as well are those datatypes are defined for the programmer's convenience but do not impact the core constructs required to build the language."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Append Function" showLineNumbers="true"',title:'"Append','Function"':!0,showLineNumbers:'"true"'},"(* Appends Two Lists *)\nfun append (l1, l2) =\n    case l1 of\n        Empty => l2\n        | Cons (x, xs) => Cons (x, append (xs, l2))\n")),(0,i.kt)("h3",{id:"polymorphic-datatypes"},"Polymorphic Datatypes"),(0,i.kt)("p",null,"The problem with our new list and option datatypes is that they only work with the ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," type while the original ones work with any type. We can fix this by making our datatypes ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"polymorphic"))," or in other words, generic. We accomplish this by adding a type variable to the definition of the datatype."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Polymorphic Datatypes" showLineNumbers="true"',title:'"Polymorphic','Datatypes"':!0,showLineNumbers:'"true"'},"(* List Datatype *)\ndatatype 'a list = Empty |\n                   Cons of 'a * 'a list\n\n(* Option Datatype *)\ndatatype 'a option = None | Some of 'a\n\n(* Tree Datatype *)\ndatatype ('a, 'b) tree = Node of 'a * ('a, 'b) tree * ('a, 'b) tree |\n                         Leaf of 'b\n")),(0,i.kt)("p",null,"The type variable can be any name and is used to represent any type. If we wanted an ",(0,i.kt)("inlineCode",{parentName:"p"},"int list"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"'a")," variable would represent ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and if we wanted a ",(0,i.kt)("inlineCode",{parentName:"p"},"string list"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"'a")," variable would represent ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". The variable will always represent the same type during the entire definition of the datatype but multiple type variables can be used in the same definition as seen with the tree where nodes can store a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"'a")," and leaves can store a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"'b"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The types ",(0,i.kt)("inlineCode",{parentName:"p"},"'a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"'b")," can be the same type making ",(0,i.kt)("inlineCode",{parentName:"p"},"('a, 'b) tree")," more generic than ",(0,i.kt)("inlineCode",{parentName:"p"},"'a tree"),".")),(0,i.kt)("h2",{id:"type-synonyms"},"Type Synonyms"),(0,i.kt)("p",null,"Our final new keyword that lets us manipulate types is ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),". This keyword allows us to create a new name for an existing type which allows us to use it interchangeably with the original type. This is useful when we want to make the type more readable or when we want to make the type more generic."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Type Synonyms" showLineNumbers="true"',title:'"Type','Synonyms"':!0,showLineNumbers:'"true"'},"datatype suit = Clubs | Diamonds | Hearts | Spades\n\n(* Type Synonym *)\ntype card = suit * rank\n\n(* Creating a Value of the Type Synonym *)\nval card_1 = (Clubs, Jack)\n")),(0,i.kt)("p",null,"Instead of always writing ",(0,i.kt)("inlineCode",{parentName:"p"},"suit * rank")," when we are referring to a card, we can use the type synonym ",(0,i.kt)("inlineCode",{parentName:"p"},"card")," which makes our code more readable."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Type synonyms are also used interchangeably by the REPL. It is completely okay to have it print out the original type instead of the type synonym.")),(0,i.kt)("h2",{id:"pattern-matching"},"Pattern Matching"),(0,i.kt)("p",null,"So far we have been able to use pattern matching to retrieve the values from a custom datatype which is very useful. However, as previously mentioned, pattern matching is powerful because it is general and so we can use it in other places as well. In fact, we can replace the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"hd"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"tl"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," with pattern matching."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Pattern Matching Lists" showLineNumbers="true"',title:'"Pattern',Matching:!0,'Lists"':!0,showLineNumbers:'"true"'},"(* Previous Approach to Appending *)\nfun append (l1, l2) =\n    if null l1\n    then l2\n    else hd l1 :: append (tl l1, l2)\n\n(* Pattern Matching Approach to Appending *)\nfun append (l1, l2) =\n    case l1 of\n        [] => l2\n        | x :: xs => x :: append (xs, l2)\n")),(0,i.kt)("p",null,"In this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," can be used to match against the empty list and ",(0,i.kt)("inlineCode",{parentName:"p"},"x :: xs")," can be used to match against a list that contains at least one element where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is the head of the list and ",(0,i.kt)("inlineCode",{parentName:"p"},"xs")," is the tail of the list. Case expressions allowed us to seperate the head from the tail of the list without having to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"hd")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tl")," functions. It also made sure we never got the head or tail of an empty list which would cause an error. This is a great example of why pattern matching is so powerful and it is better to use it instead of functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"hd")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tl"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The variables ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"xs")," can be any name and are not special. They are used to represent the head and tail of the list only. The ",(0,i.kt)("inlineCode",{parentName:"p"},"::")," operator is a constructor that stores the head and tail of the list and is what we are matching against.")),(0,i.kt)("p",null,"Furthermore, functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"isSome")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"valOf")," can be replaced with pattern matching as well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Pattern Matching Options" showLineNumbers="true"',title:'"Pattern',Matching:!0,'Options"':!0,showLineNumbers:'"true"'},"(* Previous Approach to inc_or_zero *)\nfun inc_or_zero opt = \n    if isSome opt\n    then valOf opt + 1\n    else 0\n\n(* Pattern Matching Approach to inc_or_zero *)\nfun inc_or_zero opt =\n    case opt of\n        NONE => 0\n      | SOME i => i + 1\n")),(0,i.kt)("p",null,"In this case ",(0,i.kt)("inlineCode",{parentName:"p"},"NONE")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SOME")," are the constructors of the option datatype. Just like before, by using pattern matching, we prevent ourselves from using the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"NONE"),"  in a ",(0,i.kt)("inlineCode",{parentName:"p"},"valOf")," function which would cause an error and the complier helps us make sure we handled all the cases of the option datatype."),(0,i.kt)("h3",{id:"type-inference"},"Type Inference"),(0,i.kt)("p",null,"We can also use pattern matching to extract the values from tuples and records instead of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," operator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Pattern Matching Tuples and Records" showLineNumbers="true"',title:'"Pattern',Matching:!0,Tuples:!0,and:!0,'Records"':!0,showLineNumbers:'"true"'},'fun sum_triple (triple: int * int * int) =\n    case triple of\n        (x, y, z) => x + y + z\n\nfun full_name (r: {first: string, middle: string, last: string}) =\n    case r of\n        {first = f, middle = m, last = l} => f ^ " " ^ m ^ " " ^ l\n')),(0,i.kt)("p",null,"In both cases, instead of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," operator, the pattern seperated each value of the tuple or record into variables in one go which then we could use in the expression. This approach is better than using ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," because it makes it to where it is no longer necessary to write types for our function definitions. This is because the ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," operator does not give enough information to type-check the function because the type-checker does not know what other fields the record is supposed to have, but the patterns introduced provide this information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Type Inference" showLineNumbers="true"',title:'"Type','Inference"':!0,showLineNumbers:'"true"'},'fun sum_triple triple =\n    case triple of\n        (x, y, z) => x + y + z\n\nfun full_name r =\n    case r of\n        {first = f, middle = m, last = l} => f ^ " " ^ m ^ " " ^ l\n')),(0,i.kt)("h3",{id:"variable-bindings"},"Variable Bindings"),(0,i.kt)("p",null,"Pattern matching has already been shown to be powerful with various applications but we are not done yet. We can also use patterns in variable bindings with the syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"val p = e")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," is a pattern and ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is an expression. This allows us to bind the values of an expression to variables in one go."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Variable Bindings" showLineNumbers="true"',title:'"Variable','Bindings"':!0,showLineNumbers:'"true"'},'fun sum_triple triple =\n    let val (x, y, z) = triple\n    in \n        x + y + z\n    end\n\nfun full_name r =\n    let val {first = f, middle = m, last = l} = r\n    in\n        f ^ " " ^ m ^ " " ^ l\n    end\n')),(0,i.kt)("p",null,"We can take this idea even further because function arguments are variable bindings as well. This means we can use patterns in function arguments to make the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"sum_triple")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"full_name")," even more concise, readable, and clean."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Better Variable Bindings" showLineNumbers="true"',title:'"Better',Variable:!0,'Bindings"':!0,showLineNumbers:'"true"'},'fun sum_triple (x, y, z) = \n    x + y + z\n\nfun full_name {first = f, middle = m, last = l} = \n    f ^ " " ^ m ^ " " ^ l\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Notice how the new ",(0,i.kt)("inlineCode",{parentName:"p"},"sum_triple")," function is using pattern matching to bind three variables to three pieces for the function to use but it looks exactly as a function that takes three arguments of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". It turns out every function in ML takes exactly one argument. A multi argument function is really just one argument that takes a tuple and then pattern matches on the tuple to bind the values to variables."),(0,i.kt)("p",{parentName:"admonition"},"Even when we are creating zero-argument functions, we are really just creating a function that takes in a unit value ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," which refers to nothing. Every function in ML takes exactly one argument.")),(0,i.kt)("p",null,"This flexibility that pattern matching has provided can be sometimes useful. One valuable example is the fact that we can have one function compute the results and pass it to another multi argument function immediately which is not possible in other languages keeping our code concise and clean."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Flexible Computing" showLineNumbers="true"',title:'"Flexible','Computing"':!0,showLineNumbers:'"true"'},"fun rotate_left (x, y, z) = (y, z, x) (* Multi Argument Function *)\nfun rotate_right triple = rotate_left triple (* Passes Immediately to this Function *)\n")),(0,i.kt)("h2",{id:"polymorphism"},"Polymorphism"),(0,i.kt)("p",null,"By removing explicit type annonations from our functions and opting to use pattern matching instead, we rely on the type-checker to infer the types of our functions. This is great practice but it is important to understand that the type-checker will always infer the most general type possible."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Type Inference" showLineNumbers="true"',title:'"Type','Inference"':!0,showLineNumbers:'"true"'},"(* Takes a Triple of Ints and Sum First and Third *)\nfun partial_sum (x, y, z) = x + z\n")),(0,i.kt)("p",null,"We were creating a function of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"int * int * int -> int")," but the type-checker will infer the type ",(0,i.kt)("inlineCode",{parentName:"p"},"int * 'a * int -> int")," because you only need ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," to be ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to compute the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"x + z"),". The variable ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," can be an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," as intended but it can also be any other type with no impact on the result of the function. This is called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"polymorphism"))," because it indicates that ",(0,i.kt)("inlineCode",{parentName:"p"},"int * 'a * int -> int")," is a more general type than ",(0,i.kt)("inlineCode",{parentName:"p"},"int * int * int -> int")," because it can be used in more situations including the one we intended."),(0,i.kt)("p",null,"The REPL will sometimes use type variables with two leading apostrophes like ",(0,i.kt)("inlineCode",{parentName:"p"},"''a")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"'a")," to indicate that the type variable is an ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"equality type")),". This means that the type can be any type as long as it can be compared for equality."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Equality Types" showLineNumbers="true"',title:'"Equality','Types"':!0,showLineNumbers:'"true"'},'fun same_thing (x, y) = if x = y then "yes" else "no"\nfun is_three x = if x = 3 then "yes" else "no"\n')),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"same_thing")," has the type ",(0,i.kt)("inlineCode",{parentName:"p"},"''a * ''a -> string")," which indicates that both ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," must be the same type and that type must be able to be compared using the ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," operator. On the other hand, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"is_three")," has the type ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> string")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"''a -> string")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," must be an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," operator to compare it to ",(0,i.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"If the type was ",(0,i.kt)("inlineCode",{parentName:"p"},"'a * 'b")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"(x, y)"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," could be different types or the same type. Another interesting case is if the type was ",(0,i.kt)("inlineCode",{parentName:"p"},"'a -> 'a")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," could be any type and the result of the function will return the same type it was given.")),(0,i.kt)("h3",{id:"nested-patterns"},"Nested Patterns"),(0,i.kt)("p",null,'In general, pattern matching is about taking a value and a pattern and deciding whether the pattern matches the value (the value has the same "shape" as the pattern). If it does, then the variables bind to the right values. Some key parts of the definition of pattern matching are:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A variable pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," matches any value ",(0,i.kt)("inlineCode",{parentName:"li"},"v")," and introduces one binding from ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),"."),(0,i.kt)("li",{parentName:"ol"},"The pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," matches the value ",(0,i.kt)("inlineCode",{parentName:"li"},"C"),", if ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," is a constructor that carries nothing."),(0,i.kt)("li",{parentName:"ol"},"The pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"C p")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," is a constructor and ",(0,i.kt)("inlineCode",{parentName:"li"},"p")," is a pattern matches the value ",(0,i.kt)("inlineCode",{parentName:"li"},"C v")," if the constructors are the same and ",(0,i.kt)("inlineCode",{parentName:"li"},"p")," matches ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),". If ",(0,i.kt)("inlineCode",{parentName:"li"},"p")," does match ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),", then it introduces the bindings from ",(0,i.kt)("inlineCode",{parentName:"li"},"p")," matching ",(0,i.kt)("inlineCode",{parentName:"li"},"v"),"."),(0,i.kt)("li",{parentName:"ol"},"The pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"(p1, p2, ..., pn)")," matches a tuple value ",(0,i.kt)("inlineCode",{parentName:"li"},"(v1, v2, ..., vn)")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"p1")," matches ",(0,i.kt)("inlineCode",{parentName:"li"},"v1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"p2")," matches ",(0,i.kt)("inlineCode",{parentName:"li"},"v2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"li"},"pn")," matches ",(0,i.kt)("inlineCode",{parentName:"li"},"vn"),". All the bindings from each pattern matching is introduced. A similar idea applies for record patterns where ",(0,i.kt)("inlineCode",{parentName:"li"},"{f1 = p1, ..., fn = pn}")," matches a record value ",(0,i.kt)("inlineCode",{parentName:"li"},"{f1 = v1, ..., fn = vn}"),".")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This is a recursive definition because there are instances like in the third and fourth cases where an inner pattern is in the outer pattern that needs to be matched first before the entire pattern can be matched. Patterns can nest inside other patterns allowing us to match complex values. This flexibility is what makes pattern matching so powerful.")),(0,i.kt)("p",null,"We can see the flexibility of nested patterns when we are working with lists. We can use nested patterns to get a list with a specific number of elements from a list which was difficult to do before."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"a :: (b :: (c :: d))")," matches a list with at least three elements and binds ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," to the first element, ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," to the second element, ",(0,i.kt)("inlineCode",{parentName:"li"},"c")," to the third element, and ",(0,i.kt)("inlineCode",{parentName:"li"},"d")," to the rest of the list."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"a :: (b :: (c :: []))")," matches a list with exactly three elements and binds ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," to the first element, ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," to the second element, and ",(0,i.kt)("inlineCode",{parentName:"li"},"c")," to the third element."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"(a, b, c) :: d")," matches any non empty list whose first element is a tuple of three elements and binds ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," to the first element of the tuple, ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," to the second element of the tuple, ",(0,i.kt)("inlineCode",{parentName:"li"},"c")," to the third element of the tuple, and ",(0,i.kt)("inlineCode",{parentName:"li"},"d")," to the rest of the list.")),(0,i.kt)("p",null,"We can see a pratical example of this below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Nested Patterns" showLineNumbers="true"',title:'"Nested','Patterns"':!0,showLineNumbers:'"true"'},"(* Checking if a list of integers is sorted without nested patterns *)\nfun nondecreasing intlist = \n    case intlist of\n        [] => true\n        | x :: xs => case xs of\n                        [] => true\n                        | y :: ys => x <= y andalso nondecreasing xs\n\n(* Checking if a list of integers is sorted with nested patterns *)\nfun nondecreasing intlist =\n    case intlist of\n        [] => true\n        | _ :: [] => true\n        | head :: (neck :: tail) => head <= neck andalso nondecreasing (neck :: tail)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," symbol is a wildcard pattern which means it matches any value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," but does not introduce any bindings. It is good practice to use it when we do not care about the value of a pattern. This way a useless binding is not added to the static environment.")),(0,i.kt)("h2",{id:"multi-case-functions"},"Multi Case Functions"),(0,i.kt)("p",null,"We often come across functions that have multiple case expressions as their body like with the ",(0,i.kt)("inlineCode",{parentName:"p"},"nondecreasing")," function above. This is a common pattern in ML and so the language provides another way to write these functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Multi Case Functions" showLineNumbers="true"',title:'"Multi',Case:!0,'Functions"':!0,showLineNumbers:'"true"'},"(* Syntax Without Multi Case *)\nfun f x =\n    case x of\n        p1 => e1\n        | p2 => e2\n        | ...\n        | pn => en\n\n(* Example Without Multi Case Syntax *)\nfun eval e =\n    case e of\n        Constant n => n\n        | Negate e => ~ (eval e)\n        | Add (e1, e2) => (eval e1) + (eval e2)\n        | Multiply (e1, e2) => (eval e1) * (eval e2)\n\n(* Syntax With Multi Case *)\nfun f p1 = e1\n  | f p2 = e2\n  | ...\n  | f pn = en\n\n(* Example With Multi Case Syntax *)\nfun eval (Constant i) = i\n  | eval (Negate e) = ~ (eval e)\n  | eval (Add (e1, e2)) = (eval e1) + (eval e2)\n  | eval (Multiply (e1, e2)) = (eval e1) * (eval e2)\n")),(0,i.kt)("p",null,"The syntax for multi case functions is just ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"syntactic sugar"))," because it does not add any new constructs that are fundemental to the language instead it just provides a more convenient way to write functions with multiple case expressions."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Both syntaxes are considered good practice and it is up to the programmer to decide which one they prefer to use.")),(0,i.kt)("h2",{id:"exceptions"},"Exceptions"),(0,i.kt)("p",null,"Like most languages, ML has built-in constructs for working with exceptions (errors). We can use the syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"raise e")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is an exception."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Raise Exceptions" showLineNumbers="true"',title:'"Raise','Exceptions"':!0,showLineNumbers:'"true"'},"fun hd xs =\n    case xs of\n        [] => raise List.Empty\n        | x :: _  => x\n")),(0,i.kt)("p",null,"In this case, we are raising the exception ",(0,i.kt)("inlineCode",{parentName:"p"},"List.Empty")," which is an exception defined in the standard library of ML that indicates that the list is empty. We do this because the ",(0,i.kt)("inlineCode",{parentName:"p"},"hd")," function can only work on non-empty lists. "),(0,i.kt)("p",null,"Instead of using exceptions that are already defined, ML also allows us to define our own exceptions using the syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"exception e")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is the constructor of the exception. This means that ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," can be followed by an ",(0,i.kt)("inlineCode",{parentName:"p"},"of")," keyword and a type to store a value in the exception just like with constructors found in datatypes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Define Exceptions" showLineNumbers="true"',title:'"Define','Exceptions"':!0,showLineNumbers:'"true"'},"exception MyFirstException\nexception MySecondException of int * int\n")),(0,i.kt)("p",null,"All these constructors return a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"exn")," which is the type of all exceptions. This means the exception ",(0,i.kt)("inlineCode",{parentName:"p"},"MyFirstException")," has the type ",(0,i.kt)("inlineCode",{parentName:"p"},"exn"),". On the other hand, the exception ",(0,i.kt)("inlineCode",{parentName:"p"},"MySecondException")," has the type ",(0,i.kt)("inlineCode",{parentName:"p"},"int * int -> exn")," because it takes in two ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," values to construct the exception. The fact that exceptions have their own type means we can take them as arguments for a function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Exception Arguments" showLineNumbers="true"',title:'"Exception','Arguments"':!0,showLineNumbers:'"true"'},"fun hd (xs, ex) =\n    case xs of\n        [] => raise ex\n        | x :: _ => x\n")),(0,i.kt)("p",null,"In this new version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"hd")," function, we are taking in an exception alongside the list so that if the list is empty, we can raise the exception that was passed in. The exception is only raised when the ",(0,i.kt)("inlineCode",{parentName:"p"},"raise")," keyword is used."),(0,i.kt)("p",null,"We are now able to cause an exception to be raised but we also need a way to handle exceptions if they are raised so that our program does not crash. We can use the syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"e1 handle p => e2")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"e1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"e2")," are expressions and ",(0,i.kt)("inlineCode",{parentName:"p"},"p")," is a pattern to handle exceptions. If ",(0,i.kt)("inlineCode",{parentName:"p"},"e1")," raises an exception and the exception matches the pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"p"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"e2")," is evaluated and returned instead of the exception being raised."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Handle Exceptions" showLineNumbers="true"',title:'"Handle','Exceptions"':!0,showLineNumbers:'"true"'},"(* Raises List.Empty if the List is Empty *)\nfun hd xs =\n    case xs of\n        [] => raise List.Empty\n        | x :: _ => x\n\n(* Return 0 if the List is Empty *)\nfun safe_hd xs = \n    hd xs handle List.Empty => 0\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Like with case-expressions, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," symbol to have multiple branches in our exception handling. This syntax is ",(0,i.kt)("inlineCode",{parentName:"p"},"e handle p1 => e1 | p2 => e2 | ... | pn => en")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is the expression that may raise an exception, ",(0,i.kt)("inlineCode",{parentName:"p"},"p1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"p2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"pn")," are the patterns to match against the exception, and ",(0,i.kt)("inlineCode",{parentName:"p"},"e1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"e2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"en")," are the expressions to evaluate and return if the pattern matches the exception.")),(0,i.kt)("h2",{id:"tail-recursion"},"Tail Recursion"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Tail recursion"))," is a new programming idiom (not a new language construct) that helps with writing efficient recursive functions using ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"accumulators"))," which are variables that store the result of recursive calls."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Tail Recursion" showLineNumbers="true"',title:'"Tail','Recursion"':!0,showLineNumbers:'"true"'},"(* Without Tail Recursion *)\nfun sum1 xs =\n    case xs of\n        [] => 0\n        | x :: xs' => x + sum1 xs'\n\n(* With Tail Recursion *)\nfun sum2 xs =\n    let fun f (xs, acc) =\n        case xs of\n            [] => acc\n            | x :: xs' => f (xs', x + acc)\n    in\n        f (xs, 0)\n    end\n")),(0,i.kt)("p",null,"In this case, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"sum1")," is not tail recursive and the function ",(0,i.kt)("inlineCode",{parentName:"p"},"sum2")," is. Even though ",(0,i.kt)("inlineCode",{parentName:"p"},"sum2")," is more complicated, it is more efficient than ",(0,i.kt)("inlineCode",{parentName:"p"},"sum1")," because it takes up less space on the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"call stack")),". This is a data structure with push and pop operations that stores one element for each function call made (often called a ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"stack-frame")),"). When a function is called, a new element is pushed onto the call stack and when the function is completed the element is popped off the call stack."),(0,i.kt)("p",null,"In the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"sum1 [1, 2, 3]"),", the following happens:"),(0,i.kt)("blockquote",null,(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [1, 2, 3]")," is called and a new element is pushed onto the call stack."),(0,i.kt)("li",{parentName:"ol"},"We reach the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"1 + sum1 [2, 3]")," which cannot be evaluated until ",(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [2, 3]")," is evaluated."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [2, 3]")," is called and a new element is pushed onto the call stack."),(0,i.kt)("li",{parentName:"ol"},"We reach the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"2 + sum1 [3]")," which cannot be evaluated until ",(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [3]")," is evaluated."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [3]")," is called and a new element is pushed onto the call stack."),(0,i.kt)("li",{parentName:"ol"},"We reach the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"3 + sum1 []")," which cannot be evaluated until ",(0,i.kt)("inlineCode",{parentName:"li"},"sum1 []")," is evaluated."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"sum1 []")," is called and a new element is pushed onto the call stack."),(0,i.kt)("li",{parentName:"ol"},"We reach the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," which can be evaluated. Due to the fact that the expression provided a value, the call ",(0,i.kt)("inlineCode",{parentName:"li"},"sum1 []")," is popped off the call stack."),(0,i.kt)("li",{parentName:"ol"},"The expression ",(0,i.kt)("inlineCode",{parentName:"li"},"3 + 0")," is evaluated to ",(0,i.kt)("inlineCode",{parentName:"li"},"3")," and the call ",(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [3]")," is popped off the call stack."),(0,i.kt)("li",{parentName:"ol"},"The expression ",(0,i.kt)("inlineCode",{parentName:"li"},"2 + 3")," is evaluated to ",(0,i.kt)("inlineCode",{parentName:"li"},"5")," and the call ",(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [2, 3]")," is popped off the call stack."),(0,i.kt)("li",{parentName:"ol"},"The expression ",(0,i.kt)("inlineCode",{parentName:"li"},"1 + 5")," is evaluated to ",(0,i.kt)("inlineCode",{parentName:"li"},"6")," and the call ",(0,i.kt)("inlineCode",{parentName:"li"},"sum1 [1, 2, 3]")," is popped off the call stack."),(0,i.kt)("li",{parentName:"ol"},"The recursive calls are complete and the final result is ",(0,i.kt)("inlineCode",{parentName:"li"},"6"),"."))),(0,i.kt)("p",null,"For a small list like ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 2, 3]"),", this is not as big of a deal but for a large lists, a lot of space is used on the call stack which can cause the program to crash if the call stack runs out of space. This is where tail recursion comes in because unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"sum1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sum2")," does not wait for the recursive call to be evaluated before evaluating the expression. Instead, it keeps track of the result using an accumulator."),(0,i.kt)("p",null,"In the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"sum2 [1, 2, 3]"),", the following happens:"),(0,i.kt)("blockquote",null,(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"sum2 [1, 2, 3]")," is called and a new element is pushed onto the call stack."),(0,i.kt)("li",{parentName:"ol"},"We reach the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"f ([1, 2, 3], 0)")," which evaluates to ",(0,i.kt)("inlineCode",{parentName:"li"},"f ([2, 3], 1)"),"."),(0,i.kt)("li",{parentName:"ol"},"We reach the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"f ([2, 3], 1)")," which evaluates to ",(0,i.kt)("inlineCode",{parentName:"li"},"f ([3], 3)"),"."),(0,i.kt)("li",{parentName:"ol"},"We reach the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"f ([3], 3)")," which evaluates to ",(0,i.kt)("inlineCode",{parentName:"li"},"f ([], 6)"),"."),(0,i.kt)("li",{parentName:"ol"},"The function call ",(0,i.kt)("inlineCode",{parentName:"li"},"f ([], 6)")," is evaluated and returns ",(0,i.kt)("inlineCode",{parentName:"li"},"6"),"."))),(0,i.kt)("p",null,"In this case the recursive call just returns the result of the next recursive call and has nothing else to evaluate. This means there is nothing more for the caller to do after the callee returns except return the callee's result. This idea is called a ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"tail call"))," and functional languages like ML optimize these calls. When a call is a tail call, the caller's stack-frame is popped before the call essentially replacing the callee's stack-frame with the caller's stack-frame. This basically means you only need one stack-frame for the entire recursive call no matter how many recursive calls are made."),(0,i.kt)("h3",{id:"efficiency"},"Efficiency"),(0,i.kt)("p",null,"A more interesting case of efficiency is when we are trying to reverse a list without tail recursion."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Reverse Without Tail Recursion" showLineNumbers="true"',title:'"Reverse',Without:!0,Tail:!0,'Recursion"':!0,showLineNumbers:'"true"'},"fun rev1 lst =\n    case lst of\n        [] => []\n        | x :: xs => rev1 xs @ [x]\n")),(0,i.kt)("p",null,"In this case, we always have to wait for ",(0,i.kt)("inlineCode",{parentName:"p"},"rev1 xs")," to be evaluated before we can evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"rev1 xs @ [x]"),". This algorithm is simple but it takes ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("msup",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msup"},"n"),(0,i.kt)("mn",{parentName:"msup"},"2"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n^2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"2"))))))))))))," operations to reverse a list of size ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"))))),". We get ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("msup",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msup"},"n"),(0,i.kt)("mn",{parentName:"msup"},"2"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n^2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"2"))))))))))))," because appending two lists takes time proportional to the length of the first list (it has to traverse the first list). Over all the recursive calls, we call ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," operator with the first list being length ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow"},"\u2212"),(0,i.kt)("mn",{parentName:"mrow"},"1"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow"},"\u2212"),(0,i.kt)("mn",{parentName:"mrow"},"2"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"."),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mn",{parentName:"mrow"},"1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n - 1, n - 2, ..., 1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"2"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"..."),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1")))))," and the sum of these integers from ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mn",{parentName:"mrow"},"1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1")))))," to ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow"},"\u2212"),(0,i.kt)("mn",{parentName:"mrow"},"1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n - 1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1")))))," is ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow"},"\u2217"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow"},"\u2212"),(0,i.kt)("mn",{parentName:"mrow"},"1"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"/"),(0,i.kt)("mn",{parentName:"mrow"},"2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n * (n - 1) / 2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4653em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"\u2217"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"),(0,i.kt)("span",{parentName:"span",className:"mord"},"/2")))))," which is ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("msup",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msup"},"n"),(0,i.kt)("mn",{parentName:"msup"},"2"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n^2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))))))),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sml",metastring:'title="Reverse With Tail Recursion" showLineNumbers="true"',title:'"Reverse',With:!0,Tail:!0,'Recursion"':!0,showLineNumbers:'"true"'},"fun rev2 lst =\n    let fun f (lst, acc) =\n        case lst of\n            [] => acc\n          | x :: xs => f (xs, x :: acc)\n    in\n        f (lst, [])\n    end\n")),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"rev2")," the accumulator is the reversed list so far and due to the fact we are keeping track of the list we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"::")," operator over the ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," operator. The ",(0,i.kt)("inlineCode",{parentName:"p"},"::")," operator is more efficient because it does not have to traverse any list and so it takes constant time no matter the length of the list. This means the algorithm takes ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," operations to reverse a list of size ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"n")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"rev1")," which takes ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("msup",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msup"},"n"),(0,i.kt)("mn",{parentName:"msup"},"2"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n^2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"2"))))))))))))," operations."),(0,i.kt)("h3",{id:"tail-position"},"Tail Position"),(0,i.kt)("p",null,"The most common pattern of tail recursion is where the base case of our helper function returns the accumulator and the value passed for the outermost function call is the old base case. However, it is important to note that tail recursive functions can be written in many different ways as well with the only requirement being that the recursive call is in ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"tail position"))," which means it is the last thing to be evaluated in the function and the result of the recursive call is the result of the function."),(0,i.kt)("p",null,"The precise definition of tail position can be defined recursively and is different for each expression:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"In ",(0,i.kt)("inlineCode",{parentName:"li"},"fun f(x) = e"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"e")," is in tail position."),(0,i.kt)("li",{parentName:"ol"},"If an expression ",(0,i.kt)("inlineCode",{parentName:"li"},"e")," is not in tail position, then none of its subexpressions are in tail position."),(0,i.kt)("li",{parentName:"ol"},"The expression ",(0,i.kt)("inlineCode",{parentName:"li"},"if e1 then e2 else e3")," is in tail position if both ",(0,i.kt)("inlineCode",{parentName:"li"},"e2")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"e3")," are in tail position. The expression ",(0,i.kt)("inlineCode",{parentName:"li"},"e1")," does not have to be in tail position for this case."),(0,i.kt)("li",{parentName:"ol"},"Case expressions are similar to if statements where the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"case e of p1 => e1 | p2 => e2 | ... | pn => en")," is in tail position if all the expressions ",(0,i.kt)("inlineCode",{parentName:"li"},"e1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"e2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"li"},"en")," are in tail position. However, the expression ",(0,i.kt)("inlineCode",{parentName:"li"},"e")," does not have to be in tail position."),(0,i.kt)("li",{parentName:"ol"},"The expression ",(0,i.kt)("inlineCode",{parentName:"li"},"let b1 ... bn in e")," is only in tail position if ",(0,i.kt)("inlineCode",{parentName:"li"},"e")," is in tail position. This means none of the bindings have to be in tail position."),(0,i.kt)("li",{parentName:"ol"},"Function call arguments are not in tail position.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"All these pieces all have the same underlying idea that the expression that needs to be in tail position is the expression that is returned by the outermost expression. These expressions all have to be the last thing to be evaluated in the function and should not rely on a different expression to be evaluated first in order to arrive at the result.")))}c.isMDXComponent=!0}}]);