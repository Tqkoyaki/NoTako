"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[8894],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(f,s(s({ref:t},c),{},{components:n})):a.createElement(f,s({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var u=2;u<i;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6551:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={id:"page-8",title:"Natural Numbers",sidebar_position:8},s=void 0,o={unversionedId:"turing-tako/simple-data/page-8",id:"turing-tako/simple-data/page-8",title:"Natural Numbers",description:"Natural numbers are a valuable data type that we use often in our programs so it is valuable to create a template for them.",source:"@site/docs/turing-tako/simple-data/natural.mdx",sourceDirName:"turing-tako/simple-data",slug:"/turing-tako/simple-data/page-8",permalink:"/NoTako/docs/turing-tako/simple-data/page-8",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/simple-data/natural.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{id:"page-8",title:"Natural Numbers",sidebar_position:8},sidebar:"turingSidebar",previous:{title:"Reference",permalink:"/NoTako/docs/turing-tako/simple-data/page-7"},next:{title:"Helper Functions",permalink:"/NoTako/docs/turing-tako/simple-data/page-9"}},l={},u=[{value:"Primitives",id:"primitives",level:2},{value:"Data Definition",id:"data-definition",level:2},{value:"Functions",id:"functions",level:2},{value:"Anything Can Be a Natural",id:"anything-can-be-a-natural",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Natural numbers are a valuable data type that we use often in our programs so it is valuable to create a template for them."),(0,r.kt)("h2",{id:"primitives"},"Primitives"),(0,r.kt)("p",null,"Natural numbers have a few primitives that let us create a template similar to the one we created for lists."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Add and Subtract" showLineNumbers',title:'"Add',and:!0,'Subtract"':!0,showLineNumbers:!0},"; Add one to a natural number\n(add1 0) ; => 1\n(add1 1) ; => 2\n(add1 2) ; => 3\n\n; Subtract one from a natural number\n(sub1 3) ; => 2\n(sub1 2) ; => 1\n(sub1 1) ; => 0\n\n; Check if a natural number is zero\n(zero? 0) ; => true\n(zero? 1) ; => false\n")),(0,r.kt)("p",null,"The benefit of these primitives is that it allows us to treat natural numbers like lists which will let us use self-referencing to create functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Like Lists" showLineNumbers',title:'"Like','Lists"':!0,showLineNumbers:!0},"; This is like an empty list\n(define N0 0)\n\n; This is like a list with one element\n(define N1 (add1 0))\n\n; This is like a list with two elements\n(define N2 (add1 (add1 0)))\n\n; This acts like our rest function for lists\n(sub1 N2) ; => N1\n")),(0,r.kt)("h2",{id:"data-definition"},"Data Definition"),(0,r.kt)("p",null,"Now that we know we can treat natural numbers like lists, we can create a data definition for them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Natural Numbers" showLineNumbers',title:'"Natural','Numbers"':!0,showLineNumbers:!0},"; A Natural is one of:\n; - 0\n; - (add1 Natural)\n; interp. a natural number\n\n(define N0 0) ; 0\n(define N1 (add1 N0)) ; 1\n(define N2 (add1 N1)) ; 2\n\n#;\n(define (fn-for-natural n)\n  (cond [(zero? n) (...)]\n        [else\n         (... n\n              (fn-for-natural (sub1 n)))]))\n\n; Template rules used:\n; - one of: 2 cases\n; - atomic distinct: 0\n; - compound: (add1 Natural)\n; - self-reference: (sub1 n) is Natural\n")),(0,r.kt)("p",null,"The list and natural templates are very similar where ",(0,r.kt)("inlineCode",{parentName:"p"},"(zero?)")," replaces ",(0,r.kt)("inlineCode",{parentName:"p"},"(empty?)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," replaces ",(0,r.kt)("inlineCode",{parentName:"p"},"(first l)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"(sub1 n)")," replaces ",(0,r.kt)("inlineCode",{parentName:"p"},"(rest l)"),"."),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("p",null,"Now that we have a data definition for natural numbers, we can create functions that use them. Let's create a function that returns ",(0,r.kt)("inlineCode",{parentName:"p"},"n + (n - 1) + (n - 2) + ... + 0"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Sum" showLineNumbers',title:'"Sum"',showLineNumbers:!0},"; Natural -> Natural\n; Returns the sum of all natural numbers from n to 0\n#;\n(define (sum n) 0) ; stub\n\n(check-expect (sum 0) 0)\n(check-expect (sum 1) 1)\n(check-expect (sum 3) (+ 3 2 1 0))\n\n(define (sum n)\n  (cond [(zero? n) 0]\n        [else\n         (+ n (sum (sub1 n)))]))\n")),(0,r.kt)("h2",{id:"anything-can-be-a-natural"},"Anything Can Be a Natural"),(0,r.kt)("p",null,"Often in our programs we use natural numbers to represent data like we could use 0, 1, 2 to refer to the color of a traffic light. We as programmers have the ability to create new data definitions and give data new representations in our code. This also means we can create any data type from scratch using data definitions including a new way to represent natural numbers."),(0,r.kt)("p",null,"Let's say natural numbers don't exist natively in Racket and we want to create it, we could find a new representation for them. For us let's use a list of exclamation points where a list of one ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," represents 1, two ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," represents 2, and so on."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Natural Numbers" showLineNumbers',title:'"Natural','Numbers"':!0,showLineNumbers:!0},'; A Natural is one of:\n; - empty\n; - (cons "!" Natural)\n; interp. a natural number, the number of "!" in the list is the number\n(define N0 empty) ; 0\n(define N1 (cons "!" N0)) ; 1\n(define N2 (cons "!" N1)) ; 2\n\n; We want primitives to make it easier to work with\n(define (ZERO? n) (empty? n)) ; Any -> Boolean\n(define (ADD1 n) (cons "!" n)) ; Natural -> Natural\n(define (SUB1 n) (rest n)) ; Natural[> 0] -> Natural\n\n#;\n(define (fn-for-natural n)\n  (cond [(ZERO? n) (...)]\n        [else\n         (... n\n              (fn-for-natural (SUB1 n)))]))\n')),(0,r.kt)("p",null,"This new data definition didn't use any numbers but it is still able to represent natural numbers and we can still use the same functions we created earlier the same way. This goes to show how powerful data definitions are and how we can use them to create an infinite number of new data types."))}p.isMDXComponent=!0}}]);