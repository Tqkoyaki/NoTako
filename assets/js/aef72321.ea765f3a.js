"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[164],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=u(n),f=a,h=p["".concat(l,".").concat(f)]||p[f]||m[f]||s;return n?i.createElement(h,r(r({ref:t},c),{},{components:n})):i.createElement(h,r({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var u=2;u<s;u++)r[u]=n[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8056:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var i=n(7462),a=(n(7294),n(3905));const s={id:"page-6",title:"Self Reference",sidebar_position:6},r=void 0,o={unversionedId:"turing-tako/simple-data/page-6",id:"turing-tako/simple-data/page-6",title:"Self Reference",description:"So far we have worked with variables that hold singular values but there are many situations where being able to store an arbitrary number of values would be useful. One example is being able to store a list of hockey players.",source:"@site/docs/turing-tako/simple-data/self-ref.mdx",sourceDirName:"turing-tako/simple-data",slug:"/turing-tako/simple-data/page-6",permalink:"/NoTako/docs/turing-tako/simple-data/page-6",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/simple-data/self-ref.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"page-6",title:"Self Reference",sidebar_position:6},sidebar:"turingSidebar",previous:{title:"Compound Data",permalink:"/NoTako/docs/turing-tako/simple-data/page-5"},next:{title:"Reference",permalink:"/NoTako/docs/turing-tako/simple-data/page-7"}},l={},u=[{value:"Arbitrary Sized Data",id:"arbitrary-sized-data",level:2},{value:"Creating a List",id:"creating-a-list",level:3},{value:"Working with Lists",id:"working-with-lists",level:3},{value:"Data Definition",id:"data-definition",level:2},{value:"Functions",id:"functions",level:2}],c={toc:u};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"So far we have worked with variables that hold singular values but there are many situations where being able to store an arbitrary number of values would be useful. One example is being able to store a list of hockey players."),(0,a.kt)("h2",{id:"arbitrary-sized-data"},"Arbitrary Sized Data"),(0,a.kt)("p",null,"To store an arbitrary number of values we need a list. A list is a data structure that can made up of any type of data. We can have lists of numbers, lists of strings, even lists of images."),(0,a.kt)("h3",{id:"creating-a-list"},"Creating a List"),(0,a.kt)("p",null,"The most basic list we can create is an empty list. We can create an empty list by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"empty")," keyword."),(0,a.kt)("p",null,"To create any other list we use the primitive ",(0,a.kt)("inlineCode",{parentName:"p"},"cons"),". The syntax is ",(0,a.kt)("inlineCode",{parentName:"p"},"(cons data1 data2)"),". Two arguments are required and that is all you need to create any sized list, seriously!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Creating a List" showLineNumbers',title:'"Creating',a:!0,'List"':!0,showLineNumbers:!0},"; Empty list\nempty\n\n; A list with one number\n(cons 1 empty)\n\n; A list with two numbers\n(cons 1 (cons 2 empty))\n\n; A list with five numbers\n(cons 1 (cons 2 (cons 3 (cons 4 (cons 5 empty)))))\n\n; Defining a variable to hold the list\n(define my-list (cons 1 (cons 2 empty)))\n")),(0,a.kt)("h3",{id:"working-with-lists"},"Working with Lists"),(0,a.kt)("p",null,"Now that we have a list we want to be able to play with it. There are three primitives that we can use. The ",(0,a.kt)("inlineCode",{parentName:"p"},"first")," primitive will return the first element in the list. The ",(0,a.kt)("inlineCode",{parentName:"p"},"rest")," primitive will return the rest of the list. Finally, the ",(0,a.kt)("inlineCode",{parentName:"p"},"empty?")," primitive will return true if the list is empty and false if it is not."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Working with Lists" showLineNumbers',title:'"Working',with:!0,'Lists"':!0,showLineNumbers:!0},"(define L1 (cons 1 (cons 2 (cons 3 empty))))\n\n; Get the first element in the list\n(first L1) ; 1 \n\n; Get the rest of the list\n(rest L1) ; (cons 2 (cons 3 empty))\n\n; Check if the list is empty\n(empty? L1) ; false\n(empty? empty) ; true\n")),(0,a.kt)("h2",{id:"data-definition"},"Data Definition"),(0,a.kt)("p",null,"The data definition recipe is the same for lists however there is a new template that we will use."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Type Comment and Interpretation" showLineNumbers',title:'"Type',Comment:!0,and:!0,'Interpretation"':!0,showLineNumbers:!0},"; A ListOfNumber is one of:\n; - empty\n; - (cons Number ListOfNumber)\n; interp. a list of numbers\n")),(0,a.kt)("p",null,"Before we move on, let's take a look at the type comment. A list is made up of two things, an empty list (which is a distinct value) and a compound cons cell. The ",(0,a.kt)("inlineCode",{parentName:"p"},"(cons Number ListofNumber)")," allows you to create a list of any size."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Let's check if (cons 60 (cons 42 empty)) is a ListOfNumber.\n\n- The list is not empty so we can use the second bullet.\n- It must fit (cons Number ListOfNumber), 60 is the Number so we must check if (cons 42 empty) is a ListOfNumber.\n\nLet's check if (cons 42 empty) is a ListOfNumber.\n\n- The list is not empty so we can use the second bullet.\n- It must fit (cons Number ListOfNumber), 42 is the Number so we must check if empty is a ListOfNumber.\n\nLet's check if empty is a ListOfNumber.\n\n- The list is empty so we can use the first bullet.\n\nNow if we work backwards we see that (cons 42 empty) is a ListOfNumber and therefore (cons 60 (cons 42 empty)) is a ListOfNumber.\n")),(0,a.kt)("p",null,"Using just those two bullets we can create a list of any size. Next we should look at the template..."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Template" showLineNumbers',title:'"Template"',showLineNumbers:!0},"(define (fn-for-lon lon)\n  (cond [(empty? lon) (...)]\n        [else\n         (... (first lon)\n              (fn-for-lon (rest lon)))]))\n")),(0,a.kt)("p",null,"For lists, we always want to deal with the distinct values first like empty. Once that is done, we can use the second bullet to deal with the compound values. We can only get the first element of the list so we use that and then we feed the rest of the list back into the function essentially making the list smaller every time till we get to the empty list."),(0,a.kt)("p",null,"Now that we can all the pieces of a data definition for a list together."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Data Definition" showLineNumbers',title:'"Data','Definition"':!0,showLineNumbers:!0},"; A ListOfNumber is one of:\n; - empty\n; - (cons Number ListOfNumber)\n; interp. a list of numbers\n\n(define LON1 empty)\n(define LON2 (cons 1 (cons 2 (cons 3 empty))))\n\n#;\n(define (fn-for-lon lon)\n  (cond [(empty? lon) (...)]\n        [else\n         (... (first lon)\n              (fn-for-lon (rest lon)))]))\n\n; Template rules used:\n; - One of: 2 cases\n; - Atomic distinct: empty\n; - Compound: (cons Number ListOfNumber)\n; - Self-reference: (rest lon) is ListOfNumber\n")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Because we are calling the function again with a smaller list we are using self-reference. The idea of self-reference is that you are calling the function inside itself like how ",(0,a.kt)("inlineCode",{parentName:"p"},"fn-for-lon")," is called in the definition of ",(0,a.kt)("inlineCode",{parentName:"p"},"fn-for-lon"),".")),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("p",null,"Now that we have a data definition, we can create functions using the template. Let's create a function that will sum up the double of every number in a list. If the list is empty, the sum is 0."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Double Sum" showLineNumbers',title:'"Double','Sum"':!0,showLineNumbers:!0},"; ListOfNumber -> Number\n; Sum the double of every number in the list\n#;\n(define (double-sum lon) 0) ; Stub\n\n(check-expect (double-all empty) 0)\n(check-expect (double-all (cons 60 (cons 42 empty))) (+ (* 2 60) (* 2 42)))\n\n(define (double-sum lon)\n  (cond [(empty? lon) 0]\n        [else\n         (+ (* 2 (first lon))\n            (double-sum (rest lon)))]))\n")),(0,a.kt)("p",null,"Every function has three parts, the base case, the contribution of first, and the combination of the base and the first. The base case is when the list is empty where we return 0. The contribution of first is what we do with the first element of the list. In this case, we double the value. Finally, the combination of the base and the first is how we combine the base case and the contribution of first. We do this by adding everything together."))}m.isMDXComponent=!0}}]);