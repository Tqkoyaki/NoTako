"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[1105],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=c(n),d=i,m=h["".concat(l,".").concat(d)]||h[d]||p[d]||r;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},231:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294);function i(e){return a.createElement("figure",{style:{textAlign:"center"}},a.createElement("img",{src:e.src,alt:e.caption}),a.createElement("figcaption",null,a.createElement("i",null,"Fig. ",e.num," - ",e.caption)))}},3085:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>u,toc:()=>h});var a=n(7462),i=(n(7294),n(3905)),r=n(231);const s=n.p+"assets/images/complex-data-2-80ce9dcc00f3a4e1e31e157722774453.png",o=n.p+"assets/images/complex-data-3-4bed3cb5fc0b4fc00240f787dfe7c986.png",l={id:"page-5",title:"Generative Recursion",sidebar_position:5},c=void 0,u={unversionedId:"turing-tako/complex-data/page-5",id:"turing-tako/complex-data/page-5",title:"Generative Recursion",description:"So far we have worked with structural recursion which is where each recursive call is made using a subset of the original data. This means the subset will eventually reach the base case. On the other hand, we will look at a new type of recursion called generative recursion which makes a recursive call made on data that was computed from the original data.",source:"@site/docs/turing-tako/complex-data/recursion.mdx",sourceDirName:"turing-tako/complex-data",slug:"/turing-tako/complex-data/page-5",permalink:"/NoTako/docs/turing-tako/complex-data/page-5",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/complex-data/recursion.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"page-5",title:"Generative Recursion",sidebar_position:5},sidebar:"turingSidebar",previous:{title:"Abstraction",permalink:"/NoTako/docs/turing-tako/complex-data/page-4"},next:{title:"Search",permalink:"/NoTako/docs/turing-tako/complex-data/page-6"}},p={},h=[{value:"Function",id:"function",level:2},{value:"Sierpinski Triangle",id:"sierpinski-triangle",level:3},{value:"Sierpinski Carpet",id:"sierpinski-carpet",level:3},{value:"Termination",id:"termination",level:2},{value:"Hailstone Problem",id:"hailstone-problem",level:3}],d={toc:h};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"So far we have worked with ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"structural recursion"))," which is where each recursive call is made using a subset of the original data. This means the subset will eventually reach the base case. On the other hand, we will look at a new type of recursion called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"generative recursion"))," which makes a recursive call made on data that was computed from the original data."),(0,i.kt)("h2",{id:"function"},"Function"),(0,i.kt)("p",null,"Before we can look at generative recursion in action, we have a template we can use to solve generative recursion problems."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Template" showLineNumbers',title:'"Template"',showLineNumbers:!0},"(define (genrec-fn d)\n  (if (trivial? d)\n      (trivial-answer d)\n      (... d\n           (genrec-fn (next-problem d)))))\n")),(0,i.kt)("h3",{id:"sierpinski-triangle"},"Sierpinski Triangle"),(0,i.kt)("p",null,"One way to use generative recursion is to create fractals because in each recursive call, the fractal will get bigger which means it will get more complex and for each call, the data is compounded from the original."),(0,i.kt)(r.Z,{src:s,caption:"Sierpinski Triangle",num:1,mdxType:"Fig"}),(0,i.kt)("p",null,"For the function, our input is going to be a number that returns an image. There is no subset to a number which is fine because generative recursion just needs to use the input to find the next one no matter the data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Constants, Signature, Purpose, Stub" showLineNumbers',title:'"Constants,',"Signature,":!0,"Purpose,":!0,'Stub"':!0,showLineNumbers:!0},'; This is the size of the simplest fractal\n(define CUTOFF 2)\n\n;; Number -> Image\n;; produce a Sierpinski Triangle of the given size\n\n(define (stri s)\n  (square 0 "solid" "white")) ; stub\n')),(0,i.kt)("p",null,"For the tests, we only need to test the simplest case of the fractal and one case above that because that means the generative recursion can handle the rest of the cases. This is due to the fact all the cases are built upon the first two cases."),(0,i.kt)("p",null,"In the easiest case, we have an equilateral triangle with side length s. In the second case, we have three more sierpinski triangles. To built every other case, we place three triangles inside each of those."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Tests" showLineNumbers',title:'"Tests"',showLineNumbers:!0},'(check-expect (stri CUTOFF)\n              (triangle CUTOFF "outline" "red"))\n(check-expect (stri (* CUTOFF 2))\n              (overlay (triangle (* 2 CUTOFF) "outline" "red")\n                       (local [(define sub (triangle CUTOFF "outline" "red"))]\n                         (above sub\n                                (beside sub sub)))))\n')),(0,i.kt)("p",null,"Now that we have everything, we can use the template to create the function. Our trivial case is when the size is the same size as the ",(0,i.kt)("inlineCode",{parentName:"p"},"CUTOFF"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Completed Function" showLineNumbers',title:'"Completed','Function"':!0,showLineNumbers:!0},'(define (stri s)\n  (if (<= s CUTOFF)\n      (triangle s "outline" "red")\n      (overlay (triangle s "outline" "red")\n               (local [(define sub (stri (/ s 2)))]\n                 (above sub\n                        (beside sub sub))))))\n')),(0,i.kt)("h3",{id:"sierpinski-carpet"},"Sierpinski Carpet"),(0,i.kt)("p",null,"Typically all fractals can be created using generative recursion so we will look at another fractal called sierpinski's carpet. This is where we take a square and cut it into 9 equal sized smaller squares and remove the central smaller square. We repeat this process for as many recursive calls as it takes."),(0,i.kt)(r.Z,{src:o,caption:"Sierpinski Carpet",num:2,mdxType:"Fig"}),(0,i.kt)("p",null,"Just like the last fractal, we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"CUTOFF")," size to dictate when this recursion has ended. One thing to also note is that in the triangle, for each recursive call, the size was halfed. For the carpet we need to cut the size into thirds because we are fitting 3 squares in each row."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Sierpinski Carpet" showLineNumbers',title:'"Sierpinski','Carpet"':!0,showLineNumbers:!0},';; Number -> Image\n;; produce Sierpinski carpet of given size\n#;\n(define (scarpet s)\n  (square 0 "solid" "white")) ; stub\n\n(check-expect (scarpet CUTOFF)\n              (square CUTOFF "outline" "red"))\n(check-expect (scarpet (* CUTOFF 3))\n              (overlay (square (* CUTOFF 3) "outline" "red")\n                       (local [(define sub (square CUTOFF "outline" "red"))\n                               (define blk (square CUTOFF "solid" "white"))]\n                         (above (beside sub sub sub)\n                                (beside sub blk sub)\n                                (beside sub sub sub)))))\n\n(define (scarpet s)\n  (if (<= s CUTOFF)\n      (square s "outline" "red")\n      (overlay (square s "outline" "red")\n               (local [(define sub (scarpet (/ s 3)))\n                       (define blk (square (/ s 3) "solid" "white"))]\n                 (above (beside sub sub sub)\n                        (beside sub blk sub)\n                        (beside sub sub sub))))))\n')),(0,i.kt)("h2",{id:"termination"},"Termination"),(0,i.kt)("p",null,"With structural recursion, the data sent to the recursive call is a subset of the original data so we can confidently say that eventually we will reach the simpliest case like how with lists, the simpliest case is ",(0,i.kt)("inlineCode",{parentName:"p"},"empty"),"."),(0,i.kt)("p",null,"The issue with generative recursion is that it keeps compounding the data meaning we can't always confidently state that the recursion will end. This means we need to verify that the recursion will end. We can verify this using a termination argument where we check the base case and reduction step which we use to argue that the recursion will terminate."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Termination Argument" showLineNumbers',title:'"Termination','Argument"':!0,showLineNumbers:!0},"Termination Argument for Sierpinski Triangle:\n\nBase case: (<= s CUTOFF)\n\nReduction step: (/ s 2)\n\nArgument that repeated application of reduction step will eventually\nreach the base case: As long as the cutoff is > 0 and s starts >= 0 repeated\ndivision by 2 will eventually be less than cutoff.\n\n===================================================\n\nTermination Argument for Sierpinski Carpet:\n\nBase case: (<= s CUTOFF)\n\nReduction step: (/ s 3)\n\nArgument that repeated application of reduction step will eventually\nreach the base case: As long as the cutoff is > 0 and s starts >= 0 repeated\ndivision by 3 will eventually be less than cutoff.\n")),(0,i.kt)("h3",{id:"hailstone-problem"},"Hailstone Problem"),(0,i.kt)("p",null,"For the fractals, it was easy to argue that those recursions would end. There will be cases where it will be more difficult to argue and at some points even impossible. One case of impossible is with the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Collatz Conjecture"))," which states this process will eventually reach the number 1, regardless of which positive integer is chosen initially."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-racket",metastring:'title="Hailstone Problem" showLineNumbers',title:'"Hailstone','Problem"':!0,showLineNumbers:!0},";; Integer[>=1] -> (listof Integer[>=1])\n;; produce hailstone sequence for n\n(check-expect (hailstones 1) (list 1))\n(check-expect (hailstones 2) (list 2 1))\n(check-expect (hailstones 4) (list 4 2 1))\n(check-expect (hailstones 5) (list 5 16 8 4 2 1))\n\n(define (hailstones n)\n  (if (= n 1) \n      (list 1)\n      (cons n \n            (if (even? n)\n                (hailstones (/ n 2))\n                (hailstones (add1 (* n 3)))))))\n\n=================================================\n\nTermination Argument for Hailstone Function:\n\nBase case: (= n 1)\n\nReduction step: \n    if n is even (/ n 2)\n    if n is odd (+ 1 (* n 3))\n\nArgument that repeated application of reduction step will eventually\nreach the base case: This conjecture has never been proven so \nwe just have to trust it always ends.\n")))}m.isMDXComponent=!0}}]);