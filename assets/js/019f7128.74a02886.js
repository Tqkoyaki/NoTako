"use strict";(self.webpackChunknotako=self.webpackChunknotako||[]).push([[638],{3905:(e,t,n)=>{n.d(t,{Zo:()=>g,kt:()=>m});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},g=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),h=c(n),m=i,p=h["".concat(l,".").concat(m)]||h[m]||u[m]||a;return n?r.createElement(p,s(s({ref:t},g),{},{components:n})):r.createElement(p,s({ref:t},g))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4652:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=n(7462),i=(n(7294),n(3905));const a={id:"page-3",title:"Strings and Algorithms",sidebar_position:3},s=void 0,o={unversionedId:"turing-tako/intro-to-cs/page-3",id:"turing-tako/intro-to-cs/page-3",title:"Strings and Algorithms",description:"Some ways we have worked with strings include concatenation and repeating strings using multiplication. There are other ways to work with strings that we will explore in this section because being able to work with strings is a very important skill for a programmer.",source:"@site/docs/turing-tako/intro-to-cs/stringalgo.mdx",sourceDirName:"turing-tako/intro-to-cs",slug:"/turing-tako/intro-to-cs/page-3",permalink:"/NoTako/docs/turing-tako/intro-to-cs/page-3",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/turing-tako/intro-to-cs/stringalgo.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"page-3",title:"Strings and Algorithms",sidebar_position:3},sidebar:"turingSidebar",previous:{title:"Branching and Iteration",permalink:"/NoTako/docs/turing-tako/intro-to-cs/page-2"},next:{title:"Functions",permalink:"/NoTako/docs/turing-tako/intro-to-cs/page-4"}},l={},c=[{value:"Strings",id:"strings",level:2},{value:"Indexing Strings",id:"indexing-strings",level:3},{value:"Slicing",id:"slicing",level:3},{value:"Immutability",id:"immutability",level:3},{value:"Algorithms",id:"algorithms",level:2},{value:"Guess and Check",id:"guess-and-check",level:3},{value:"Approximation",id:"approximation",level:3},{value:"Bisection Search",id:"bisection-search",level:3}],g={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Some ways we have worked with strings include ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"concatenation"))," and repeating strings using multiplication. There are other ways to work with strings that we will explore in this section because being able to work with strings is a very important skill for a programmer."),(0,i.kt)("p",null,"Now that we have worked with a lot of programming concepts, we can start to combine them to solve more complex problems."),(0,i.kt)("h2",{id:"strings"},"Strings"),(0,i.kt)("p",null,"As stated before, strings are a sequence of characters. We can start by using ",(0,i.kt)("inlineCode",{parentName:"p"},"len()")," to find the length of a string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Length of a String" showLineNumbers',title:'"Length',of:!0,a:!0,'String"':!0,showLineNumbers:!0},'len("Hello World") # 11\n')),(0,i.kt)("h3",{id:"indexing-strings"},"Indexing Strings"),(0,i.kt)("p",null,"You can access individual characters in a string using the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"index"))," of the character. The index of a string marks its position in a string and positions start with 0. The index of the first character in a string is 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H e l l o   W o r l d\n0 1 2 3 4 5 6 7 8 9 10\n\nW is at index 6\nd is at index 10\n\nl is at indices 2, 3, and 9\n")),(0,i.kt)("p",null,"In Python, you can access the character at a specific index using square brackets ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Accessing a Character" showLineNumbers',title:'"Accessing',a:!0,'Character"':!0,showLineNumbers:!0},'print("Hello World"[6]) # W\n\nmsg = "Hello World"\nprint(msg[2]) # l\nprint(msg[6]) # W\nprint(msg[10]) # d\n')),(0,i.kt)("p",null,"Python is special because it also allows you to use negative indices. Negative indices start at -1 and count backwards from the end of the string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H  e  l  l  o\n0  1  2  3  4\n-5 -4 -3 -2 -1\n")),(0,i.kt)("p",null,"You use the same square brackets ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," to access a character at a negative index."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Negative Indices" showLineNumbers',title:'"Negative','Indices"':!0,showLineNumbers:!0},'msg = "Hello"\n\nprint(msg[-1]) # o\nprint(msg[-2]) # l\nprint(msg[-5]) # H\n')),(0,i.kt)("h3",{id:"slicing"},"Slicing"),(0,i.kt)("p",null,"You can access a range of characters using the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"slice"))," operator ",(0,i.kt)("inlineCode",{parentName:"p"},":"),". It is similar to the range function we used in the previous section."),(0,i.kt)("p",null,"If one value is provided inside the square brackets, it will return the character at that index."),(0,i.kt)("p",null,"If two values are provided inside the square brackets, it will return the characters from the first index to the second index, not including the second index."),(0,i.kt)("p",null,"If three values are provided inside the square brackets, it will return the characters from the first index to the second index, not including the second index, and it will increment by the third value. The third value is called the step."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Slicing" showLineNumbers',title:'"Slicing"',showLineNumbers:!0},'msg = "Hello World"\n\n# Indexing one value\nprint(msg[6]) # W\nprint(msg[-1]) # d\n\n# Slicing two values\nprint(msg[0:5]) # Hello\nprint(msg[6:11]) # World\n\n# Slicing three values\nprint(msg[0:5:2]) # Hlo\nprint(msg[6:11:2]) # Wrd\n')),(0,i.kt)("h3",{id:"immutability"},"Immutability"),(0,i.kt)("p",null,"One thing you cannot do with strings is modify them. Strings are ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"immutable")),", which means they cannot be changed. You can only create new strings from existing strings."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Immutability" showLineNumbers',title:'"Immutability"',showLineNumbers:!0},'msg = "Hello World"\nmsg[0] = "h" # Error\n\nmsg = "M" + msg[1:] # Mello World\n')),(0,i.kt)("p",null,"The variable ",(0,i.kt)("inlineCode",{parentName:"p"},"msg")," gets rebinded to a new string so we aren't modify the original string just replacing it with a new string."),(0,i.kt)("h2",{id:"algorithms"},"Algorithms"),(0,i.kt)("p",null,"An ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"algorithm"))," is a well defined set of instructions with a systematic order that can solve any given problem. Algorithms give computer scientists a way to solve complex problems in a systematic way."),(0,i.kt)("h3",{id:"guess-and-check"},"Guess and Check"),(0,i.kt)("p",null,"Another name for guess and check is ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Exhaustive Enumeration")),". It is an algorithm that keeps trying different values until it finds the correct answer."),(0,i.kt)("p",null,"One example of guess and check is finding the square root of a number. You can guess the square root of a number by guessing a number and then checking if the square of that number is the same as the original number. If it is not, you can try a different number. You can keep trying different numbers until you find the correct answer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Guess and Check" showLineNumbers',title:'"Guess',and:!0,'Check"':!0,showLineNumbers:!0},"# The number we are trying to find the square root of\nx = 25\n\n# Guess and Check\nfor guess in range(1, x): # Check all numbers till x\n    if guess ** 2 == x: # Check if guess is the square root\n        print(guess) # Print the guess if it is correct\n        break # Leaves the loop\n")),(0,i.kt)("h3",{id:"approximation"},"Approximation"),(0,i.kt)("p",null,"The guess and check algorithm above works if ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is a perfect square. What if ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is not a perfect square? We can use a different algorithm called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Approximation"))," to find the square root of a number. It guesses like the guess and check algorithm but it adds on to it by incrementing by a small amount and accepting the guess if it is close enough."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Approximation" showLineNumbers',title:'"Approximation"',showLineNumbers:!0},"# The number we are trying to find the square root of\nx = 25\n\n# Our margin of error\nepsilon = 0.01\n\n# The increment\nstep = 0.01\n\n# The guess and check with approximation\nguess = 0.0\nwhile abs(guess ** 2 - x) >= epsilon and guess <= x: # Check if guess is close enough\n    guess += step # Increments as long as the guess is not close enough\n\nprint(guess) # Print the answer\n")),(0,i.kt)("p",null,"The bigger the step or the bigger the epsilon (margin of error), the faster the algorithm will run but the less accurate it will be."),(0,i.kt)("h3",{id:"bisection-search"},"Bisection Search"),(0,i.kt)("p",null,"The approximation algorithm can find the square root of most numbers but it is not the most efficient algorithm. Typically any algorithm that checks every possible answer is not the most efficient algorithm. We can use a different algorithm called ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Bisection Search"))," to write more efficient algorithms. It works by checking the middle of a range of values and then eliminating half of the range by seeing what side of the middle the answer is on."),(0,i.kt)("p",null,"Similar to a higher or lower game, you can guess the square root of a number by guessing the middle of the range of number and if the guess is too high or too low, you can eliminate half of the range and guess the middle of the remaining range."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Bisection Search" showLineNumbers',title:'"Bisection','Search"':!0,showLineNumbers:!0},"# The number we are trying to find the square root of\nx = 25\n\n# Our margin of error\nepsilon = 0.01\n\n# The bounds\nlow = 0.0\nhigh = x\n\n# Checks the middle of the range\nguess = (low + high) / 2.0\n\n# The bisection search\nwhile abs(guess ** 2 - x) >= epsilon:\n    if guess ** 2 < x: # If the guess is too low\n        low = guess # Eliminate the lower half of the range\n    else: # If the guess is too high\n        high = guess # Eliminate the upper half of the range\n    guess = (low + high) / 2.0 # Check the middle of the range\n\nprint(guess) # Print the answer\n")),(0,i.kt)("p",null,"This is a more efficient algorithm because it only checks the middle of the range instead of every possible answer. The number of guesses converges on the order of log",(0,i.kt)("sub",null,"2"),"(n) where n is the number of possible answers."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Bisection search only works on nonincreasing or nondecreasing lists. It will not work for ranges that are not sorted because you cannot reasonably eliminate half of the range and be sure the answer is in the remaining range.")))}u.isMDXComponent=!0}}]);