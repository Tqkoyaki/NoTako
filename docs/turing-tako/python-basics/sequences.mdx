---
id: page-3
title: Sequences
sidebar_position: 3
---
Sometimes you want to store a list of values that are related to each other and creating a variable for each one would be excessive, inefficient, and will never be flexible for many needs. This is why we have data structures to organize more complex data and the first example of a data structure is a list. A list holds a sequence of values.

## Creating Lists
You can create a list with square brackets and commas separating the values. You can also use `list()` to create a list.

```python title="Creating Lists" showLineNumbers
[1, 2, 3] # (1) Creating Lists
['abc', 'def', 'ghi']
list([1, 2, 3])

[1, 'abc', 2, 'def', 3, 'ghi'] # (2) Multiple Types of Values

[] # (3) Empty List
list()
```
1. You can create a list with square brackets `[]` and commas seperating the values.
2. In Python, lists can hold multiple types of values.
3. You can create an empty list with `[]` or `list()`.

## Accessing List Values
The first thing we want to do is retrieve a value from the list, to do this we need to use an ***index***. In most programming languages like Python, we index lists starting at 0. This means the first item is indexed at 0, the second item is indexed at 1.

```python title="Indexing Lists" showLineNumbers
names = ["bob", "steve", "john"]
print(names[0]) # Prints "bob" [first item]
print(names[2]) # Prints "john" [third item]

names[2] = "jane" # Replaces "john" with "jane"

print(names[3]) # ERROR! (1)
```
1. This will throw an error because there is no item at index 3. The last item is at index 2.

## List Methods
There are a few ***methods*** that are useful for lists. These are built in tools that are available to use in Python.

```python title="List Methods" showLineNumbers
names = ["bob", "steve", "john"]

print(len(names)) # Prints 3 [length of list]
names.append("jane") # Adds "jane" to the end of the list

deletedItem = names.pop() # Removes the last item from the list and returns it
deletedItem = names.pop(1) # Removes the item at index 1 and returns it

del names[0] # Removes the item at index 0

print(max(names)) # Prints "steve" because it is alphabetically last so the biggest
print(min(names)) # Prints "bob" because it is alphabetically first so the smallest
print(sum(names)) # ERROR! (1)
```
1. This will throw an error because you can't add strings together. But this would work for a list of numbers.

:::caution
Not all methods are avaliable for all data types. Googling `python [method name]` typically will give you information about the method.
:::

## Strings are Lists Too
Even through strings are a data type in Python, they are technically just a list of characters, this means we can do many things with strings that we can do with lists.

The difference between a list and a string is that a string is ***immutable***, this means we cannot change the value of a string. We can read the values of a string the same way as lists but we cannot change them.

```python title="Strings Methods" showLineNumbers
name = "bob"
print(name[0]) # Prints the first character "b"
print(len(name)) # Prints 3 [length of string]

name.append("j") # Error because strings are immutable

del name[0] # Error because strings are immutable
```

All the things we can do with a string are also available to us with lists.

```python title="Lists Expressions" showLineNumbers
names = ["bob", "steve", "john"]
names2 = ["dave", "jane"]

names3 = names + names2 # Appends the values of names2 to the end of names
names4 = names * 2 # Repeats the values of names twice
```

### More String Functionality

There are a few more string specific methods there that are useful. These type of methods are ***invocations***, which are functions that are called on a value.

```python title="String Methods" showLineNumbers
stuff = ' Hello world '

stuff.upper() # (1) HELLO WORLD
stuff.lower() # hello world

stuff.find('o') # (2) 4

stuff.strip() # (3) 'Hello world'

stuff.startswith('Hello') # (4) True
stuff.endswith('world') # False

stuff.split() # (5) ['Hello', 'world']
stuff.split('o') # ['Hell', ' w', 'rld']
```
1. `upper()` returns the string in all uppercase letters, `lower()` returns the string in all lowercase letters.  
2. `find()` returns the index of the first occurance of the character, if it doesn't exist it returns -1.  
3. `strip()` removes all whitespace from the beginning and end of the string.  
4. `startswith()` returns `True` if the string starts with the given string, `endswith()` returns `True` if the string ends with the given string.    
5. `split()` returns a list of strings that are split at the given character, if no character is given it splits at whitespace.  

What makes these methods different from other methods is that we use the . notation to call them. The syntax here is `<value/variable>.<method name>()`. This is called ***dot notation***.

### Formating Strings
One common use of strings is to format results and displaying them to a user. There are many instances where you want to use the values of variables in strings and the + operator can make the code messy and hard to read. You can use the built in `%` operator to format strings.

```python title="Formating Strings" showLineNumbers
name = "bob"
age = 20
'Hello, my name is %s and I am %d years old.' % (name, age) # (1) Hello, my name is bob and I am 20 years old.
```
1. The `%` operator takes the string and replaces the `%s` with the first value in the parentheses and the `%d` with the second value in the parentheses.

You can have as many values as you want formatted. Inside the string the letter after the % is the type of value you want to format. The types are:

| Type | Description |
| :--- | :--- |
| `s` | String |
| `d` | Integer |
| `f` | Float |
| `c` | Character |
| `b` | Boolean |

## Slicing Lists
One useful functionality built into Python is list slicing which lets you get a subset of a list and because this is not changing the contents of the list, it works with strings too.

```python title="List Slicing" showLineNumbers
names = ["bob", "steve", "john", "dave", "jane"]
names2 = names[1:3] # Gets the second and third items from the list
names3 = names[1:] # Gets all the items from the second item to the end
names4 = names[:3] # Gets all the items from the start to the third item
names5 = names[:] # Gets all the items from the start to the end
```

The syntax used here is `list[start:end]` where `start` is the index of the first item to get and `end` is the index of the first item to not get. This means that `list[start:end]` will get all items from `start` to `end - 1` because the item at `end` is not included.

If the start or end is not specified, it will default to the start or end of the list.

You can also skip items in a list by using a third number in the slice. The syntax is `list[start:end:skip]` where `skip` is the number of items to skip.

```python title="List Slicing with Skip" showLineNumbers
names = ["bob", "steve", "john", "dave", "jane"]
names2 = names[1:4:2] # Gets the second and fourth items from the list
names3 = names[1::2] # Gets all the items from the second item to the end skipping every other item
names4 = names[:4:2] # Gets all the items from the start to the fourth item skipping every other item
names5 = names[::2] # Gets all the items from the start to the end skipping every other item
```

### Negative Indexing
Python is unique in that it allows you to use negative numbers to index lists. This is useful because it lets you get items from the end of the list.
    
```python title="Negative Indexing" showLineNumbers
names = ["bob", "steve", "john", "dave", "jane"]
print(names[-1]) # Prints "jane"
print(names[-2]) # Prints "dave"

print(names[-3:]) # (1) Prints ["john", "dave", "jane"]

print(names[::-1]) # (2) Prints ["jane", "dave", "john", "steve"]
```
1. This gets all the items from the third item from the end to the end of the list.
2. This is a popular way to reverse a list.

Overall, list splicing and negative indexing allow for various creative ways to get the exact items you want from a list and a great tool to have in your toolbox.